\chapter{Design}

% We want to extend the work of Arquint et al.\ \cite{} to support the safe deletion of old data.
% Practically, we want to extend their Reusable Verification Library in order to provide someone verifying a protocol implementation with the possibility of proving security properties like post-compromise security.

% Explain that we will use "the developer" to mention the person who will use the library to verify a protocol implementation

\section{Overview}
\label{sec:overview}
% TODO_ Isn't it more of an introduction?

This section gives an overview to better understand the high-level idea of our methodology.

With the aim of verifying properties like forward secrecy and post-compromise security for a protocol implementation, we need to model the fact that some ephemeral values should only exist for a limited amount of time.
To do so, we first add a way to specify temporality at the verification level: \emph{versions}, that define time frames during which some terms are accessible.
Then, as we specify that a term should only be able to exist in some time frame, we reason about how to enforce that it is deleted before this time frame ends.

\subsection{Goal}
\label{sec:goal}

We aim to verify protocol implementations that frequently renew their communication keys to provide strong security properties.
A notable example is the Signal Double Ratchet protocol. To make our point simpler, we consider a simplified version of this protocol, the Diffie-Hellman (DH) ratchet.
The DH ratchet is a continuous key agreement protocol, that repeatedly performs Diffie Hellman key exchanges to encrypt each message with its own key.
% TODO_ Add a figure: Can I reuse the one from DY*?
% TODO_ Should I explain what a DH key exchange is?

It starts with an established key $K_0$, mutually shared by both participants.
The initiator uses the responder's public key and a newly generated secret key to compute a Diffie-Hellman secret. 
This newly generated secret is then blended with $K_0$, resulting in the derivation of a fresh key $K_1$.
This step of generating a new key from the previous one is called a \emph{ratcheting step}.
Then, $K_1$ is used to encrypt the message sent to the responder, accompanied by the initiator's new public key.
The responder can obtain the Diffie-Hellman shared secret and take the same ratcheting step to obtain $K_1$, then use it to decrypt the message.
This iterative process continues for each message, with the initiator and the responder continuously ratcheting.

After this ratcheting process has been performed and has given us a key $K_n$, the previous key $K_{n-1}$ is no longer needed and is deleted.

% TODO_ Explain how this relates to forward secrecy and post-compromise security.


\subsection{Versions}
\label{sec:versions}

% TODO_ Versions must have been introduced in the DY* chapter of the Background
In order to introduce a notion of temporality, we introduce a \emph{version} identifier, similarly to what is done in DY*. Each participant's session is given a version field, initially set to $0$, that keeps track of the current version of the protocol.
Each term, e.g. a key or a nonce, is assigned a secrecy label stating who can access it. While these labels could previously only be defined from participant or session identifiers, we now allow them to be defined from version identifiers as well. Formally, a version identifier is a triplet identifier of the form $(p, s, v)$, where $p$ is a participant, $s$ is a session, and $v$ is a version.

We distinguish two cases: \emph{versioned} and \emph{unversioned} terms.
A term is said to be versioned if it is made to be accessible only in one or several specific versions, while it is said to be unversioned if it is made to be accessible by a participant or a session. 
An unversioned term accessible by some session is therefore accessible by all versions of that session.

The existing methodology already enforces that unversioned terms can only be accessed by participants or sessions allowed by their secrecy label.
A key property of our methodology extension is to ensure that versioned terms can only be accessed by the specific versions allowed by their secrecy label. Intuitively, this means that an ephemeral key, defined as a versioned value, should only be accessible during a limited time frame defined by the versions allowed by its secrecy label.

On a high level, this requires two kinds of checks.
First, we enforce when creating a versioned term that it should be readable in the current version of the protocol.
Second, we enforce that when increasing the version of a session, all versioned terms that are no longer accessible in the new version are deleted.
While the first check can be easily implemented similarly to the existing check for unversioned terms, the second check requires more work. Indeed, using Gobra, there is no trivial way to check a condition on \emph{all versioned terms}.

This second check is crucial as it will drive the deletion mechanism, and ensure that ephemeral keys are deleted when they are no longer needed. Let us discuss this in more detail.

% TODO_
% - Say that it does not change to ability to verify unversioned protocols in the same way
% - Write somewhere about terms with a label containing a session and a version of the same session

\subsection{Enforcing deletion of old data}
\label{sec:enforcing-deletion-of-old-data}

Before increasing the version of a session, we have to securely delete all versioned terms that are no longer accessible in the new version. By doing so, we more generally ensure that terms are only accessible in the time frames allowed by their secrecy label.

While this problem has already been solved in DY*, we show that their approach is not applicable in our case. We then introduce our approach on a high level.

\subsubsection{Existing approach in DY*}
\label{sec:existing-approach-in-dy}

In DY*, a participant uses a storage API to store all of its knowledge on the trace.
In particular, it stores the knowledge of ongoing sessions into an array, composed of each serialized session state.
Each session is given a version number.
To update some session state, the participant first reads and deserializes the corresponding session state from the array, then modifies it, and finally serializes and stores it back into the array.
The participant can also update and increment the version number at this point.

Upon serialization and storage of the updated check, an invariant is checking that only values still accessible in the session's version are stored.
Thus, only data from the current version can be stored, ensuring that neither outdated keys nor future keys are present in memory.
Building on this, they can prove forward secrecy and post-compromise security for protocols like Signal.

However, DY* does not enforce that outdated keys are \emph{securely} deleted from memory. They only show that they are not present in the current scope, but outdated keys are not explicitly zeroed out from memory.
Moreover, this solution does not apply to existing implementations because their state is not stored on a trace, making it impossible to express such an invariant.
Furthermore, DY* enforces the invariant over state only at certain time points, namely when the state is stored on the trace, without taking into account the state in-between.
% TODO_ Is this relevant?

\subsubsection{Our approach}
\label{sec:our-approach}

As we cannot simply iterate over the full session state to remove outdated keys like in DY*, we present a new approach to enforce that versioned values are deleted before they are no longer accessible.

The intuition of the methodology is to let the developer (that is verifying a protocol implementation) choose when to delete a versioned value.
We allow them to do so by providing a \emph{secure} deletion function that is their only way to delete a value. This secure function takes care of fully erasing the value from memory.
The crucial aspect now is to verify that, before the session version is incremented, the secure deletion function has been called for all versioned values that will no longer be accessible in the new version.

Intuitively, we could solve this problem with a counter. Starting with version $i$, we use the counter $c_i:=0$.
Each time we create a versioned value readable in version $0$, we increment the counter $c_i = c_i + 1$.
And each time we delete a versioned value readable in version $0$, we decrement the counter $c_i = c_i - 1$.
When we increment the version of the session, we check that $c_i = 0$, meaning that all versioned values readable in version $i$ have been deleted.

% TODO_ Should I mention that this easy explanation does not work for values readable in multiple versions, and refer the reader to a future section?

With this approach, one could think that the developer could just never increment the version of the session, and thus would never have to delete any versioned value. While this is true, if the developer wants to verify meaningful properties like forward secrecy, they will have to increment the version at some point to express the property in terms of the version.

However, this approach cannot be trivially implemented in our case because we cannot just use a counter \emph{variable} that the developer could access at will: they would just have to manually set it to $0$ before incrementing the version of the session, and the counter check would be meaningless.
% Additionally, this simplified approach has several limitations, that will be discussed case by case in section \ref{sec:}.

To solve this problem without the limitations of a counter variable, we will create a mechanism based on \emph{counting permissions}. Those will be explained in the next section, before using them to design our deletion mechanism.

\section{Counting permissions}
\label{sec:counting-permissions}

Because keeping track of created and deleted values using a counter variable could be easily bypassed by the developer, we base our work on counting permissions.
In this section, we build our method on the same intuition as the approach explained above, but using counting permissions should prevent the developer from circumventing the deletion mechanism.

We start by introducing the notion of counting permissions.
Because these permissions are not available in the current version of Gobra, we then explain how we can obtain similar functionality using the existing permission system.

\subsection{Introduction}
\label{sec:counting-permissions-introduction}

Counting permissions are a permission model where permission shares are valued in $\mathbb{Z}\cup\{u\}$, where $u$ represents the identity element of the share addition operation. A share of value $0$ means full permission, a share of value $u$ means no permission, and any other value means partial permission. A non-negative share $n\geq0$ is called a token \emph{factory} and can be split, for any integer $k>0$, into another factory $n+k$ and an equivalent amount of negative token \emph{bundles} of value $-k<0$. A token factory and some amount of token bundles can be summed, and the result is always non-negative (because the subtracted bundle value had to be added to the factory before). 

In practical terms, this means that starting with full permission ($0$) of some predicate one could use it as a counter. It could be incremented by splitting it into a factory~$1$ and a bundle~$-1$. A second increment would create a factory~$2$ and a second bundle~$-1$. Invertly, decrementing the counter could be done by summing the factory~$2$ with a bundle~$-1$, resulting in a factory~$1$.

In our use case, using this counting permissions model, we could use a dummy predicate $p_i$, on which we initially have full permission $n:=0$. The library functions that create a versioned term readable in version $i$ would require access to the token factory $n\geq0$ of $p_i$, and would return an incremented share $n+1$, \emph{without} returning the token bundle $-1$. Invertly, the secure delete function would return a token bundle $-1$ upon deletion of a versioned term readable in version $i$. Therefore, if the developer deletes all $i$-versioned terms, he will obtain as many token bundles $-1$ as the value of the token factory $n$. Summing them together will result in a full permission $n = 0$. This means that we know that no $i$-versioned values exist in memory when we have full permission on $p_i$.

The major difference with a simple counter variable is that the developer \emph{cannot} create a $-1$ token bundle the way they could just decrement the counter variable. They \emph{have to} delete all $i$-versioned terms and cannot circumvent the deletion mechanism.

% TODO_ "-1 token bundle" or "token bundle -1"?

\subsection{Implementation in Gobra}
\label{sec:implementation-in-gobra}

% TODO_ The fractional permission system must have been introduced in the Background chapter
Gobra does not use counting permissions and relies only on the fractional permissions model.
Recall that in this model, permission shares are valued in $[0,1]\cap\mathbb{Q}$, and a share of value $0/1$ means no permission, a share of value $1/1$ means full permission, and any other value means partial permission.

While fully replicating counting permissions from fractional permissions does not seem possible, we just need to obtain some level of functionality sufficient to implement our deletion mechanism.

\subsubsection{Idea}
\label{sec:counting-permissions-idea}

We introduce below the two abstract predicates that we will use to implement our deletion mechanism.

\begin{gobra}
pred guard(v uint32)
pred receipt(key []byte, v uint32)
\end{gobra}

The \texttt{guard} predicate can be seen as the token factory and is initially given with full permission ($1/1$) to the developer.
The \texttt{receipt} predicate can be seen as a token bundle.
The idea is for all library functions that create a versioned value \texttt{key} readable in version \texttt{v} to require partial permission to \texttt{guard(v)}, and to return the same amount of permission of \texttt{receipt(key, v)}.
Then, upon deletion of \texttt{key}, the secure deletion function requires some amount of permission of \texttt{receipt(key, v)} and returns the same amount of permission of \texttt{guard(v)}.

In practice, the developer may have to create several \texttt{v}-versioned values and will consume some amount of permission of \texttt{guard(v)} for each of them.
They will receive the same amount of permission of \texttt{receipt(key, v)} for each of them.
When they want to increment the version of the session, they will have to delete all \texttt{v}-versioned values and will consume all \texttt{receipt(key, v)} fractional permissions.
They will receive the same amount of permission of \texttt{guard(v)} for each of them.
Therefore, we know that no versioned value readable in version \texttt{v} remains in memory when we have full permission on \texttt{guard(v)}.
Consequently, we require full permission on \texttt{guard(v)} to call the function that increments the version of the session.

Similarly to counting permissions, the developer cannot bypass the deletion mechanism because he cannot obtain \texttt{guard} or \texttt{receipt} fractional permissions without going through the library functions.
This is assuming that the developer does not use Gobra's \texttt{inhale} or \texttt{assume} statements to bypass the permission system.

Note that the receipt predicate takes the created byte array \texttt{key} as an argument.
This is used at deletion to verify that we delete the actual value associated with the receipt, before returning the \texttt{guard(v)} permission fraction. Otherwise, the developer could simply delete arbitrary (unversioned) values to transform some \texttt{receipt(key, v)} permission fraction into a \texttt{guard(v)} permission fraction, and circumvent the guarantee of deletion of versioned values.

\subsubsection{Developer responsibility}
\label{sec:developer-responsibility}

With this Gobra implementation, the developer is given more responsibility than in the counting permissions model.
Indeed, upon creating or deleting a versioned value, the developer chooses the permission amount of the \texttt{guard} or \texttt{receipt} that will be consumed.

When creating versioned values, the developer has to choose small enough permission amounts of \texttt{guard} to consume so that all values can be created.
For example, if they want to create $3$ versioned values, but consume $1/2$ of \texttt{guard} for the two first values, they will not be able to create the third value because they will not have enough permission of \texttt{guard} left.
This does not affect the soundness of the methodology but simply prevents the developer from implementing their goal.
It is therefore their responsibility to carefully choose permission amounts.

When deleting versioned values, the developer has to specify the full permission amount of \texttt{receipt} to consume.
Indeed, in Gobra, we currently cannot know how much permission of \texttt{receipt} is available in the current context.
This is why the developer has to manually specify the full permission amount of \texttt{receipt} to consume.
However, they could specify a smaller amount than the amount they have, and the deletion function call would work.
However, by doing so, the developer will never be able to retrieve the full \texttt{guard} permission, which will prevent them from incrementing the version of the session.
Again, the methodology's soundness remains unaffected, the only consequence is the developer's inability to realize their objective.
It is therefore their responsibility to specify the full \texttt{receipt} permission amount upon deletion.

At the end of the day, we have identified a satisfactory approach for achieving functionality reminiscent of counting permissions in Gobra. Despite placing additional responsibility on the developer, this method is sound and constitutes the core of our deletion mechanism.

\section{Extension of the library}
\label{sec:extension-of-the-library}

We introduced a general mechanism to enforce the deletion of versioned values before the end of their time frame, defined in terms of versions allowed by their secrecy label.
This mechanism is central to the methodology.
In this section, we explain how we integrate it in Arquint's et al.\ Reusable Verification Library, to provide the developer with functions handling versioned values.

% TODO_ outline what is said in the following subsections

\subsection{Storing the current session version}
\label{sec:storing-the-current-session-version}

% TODO_ Do I need this? What should I write?
% Need explanations of the LabeledLibrary, the Owner() and OwnerWithVersion(), CanFlow

\subsection{Creation of versioned values}
\label{sec:creation-of-versioned-values}

The library provides three functions to create values: \texttt{CreateNonce} to create some random value, \texttt{GeneratePkeKey} to create a public/private key pair, and \texttt{GenerateDHKey} to create a secret key for Diffie-Hellman key exchange. Those three functions are implemented very similarly and have required the same changes to support versioned values. Therefore, we will only discuss the \texttt{CreateNonce} function in this subsection. Its simplified implementation is provided in Figure \ref{lst:create-nonce}.

\begin{figure}
    \begin{gobra}
requires versionPerm >= 0
requires versionPerm == 0 ==>
    tri.GetLabeling(l.Ctx()).CanFlow(l.Snapshot(), nonceLabel,
                               label.Readers(set[p.Id]{ l.Owner() }))
requires versionPerm > 0 ==>
    acc(lib.guard(l.Version()), versionPerm) &&
    l.Owner().IsSession() &&
    tri.GetLabeling(l.Ctx()).CanFlow(l.Snapshot(), nonceLabel,
                    label.Readers(set[p.Id]{ l.OwnerWithVersion() }))
ensures  err == nil && versionPerm > 0 ==>
    acc(lib.receipt(nonce, l.Version()), versionPerm)
func (l *LabeledLibrary) CreateNonce(ghost nonceLabel SecrecyLabel,
       ghost versionPerm perm) (nonce []byte, err error) {
    // ...
}
    \end{gobra}
    \caption{Implementation of \texttt{CreateNonce} showcasing the changes to support versioned values. Preconditions, postconditions and arguments that are not relevant to the changes have been omitted.}
    \label{lst:create-nonce}
\end{figure}

This function takes a \texttt{versionPerm} argument, that is required to be non-negative.
The developer can use this argument to specify whether they want to create a versioned or unversioned nonce. Choosing $0$ means that the nonce will be unversioned, and choosing a strictly positive value means versioned.

\subsubsection{Unversioned nonce}
\label{sec:unversioned-nonce}

In this case, the developer chooses $0$ for the \texttt{versionPerm} argument.
The only additional precondition (lines 3 and 4) to satisfy is that the given nonce label should flow to the library owner.
Depending on if sessions are used, the library owner is either a participant $(p)$ or a session $(p,s)$ identifier.

Because no version identifier $(p,s,v)$ flows to $(p,s)$ or $(p)$, we know when verifying this precondition that the nonce label must be composed of some non-versioned identifier, e.g. is unversioned.
Therefore, when the developer chooses $0$ for the \texttt{versionPerm} argument and proves that the nonce label is unversioned, then the library behaves as the original implementation and creates an unversioned nonce, without consuming any permission of \texttt{guard}.

\subsubsection{Versioned nonce}
\label{sec:versioned-nonce}

In this second case, the developer chooses a strictly positive \texttt{versionPerm} value.
This value is used to specify the amount of permission of \texttt{guard} to consume (line 6), as discussed in section \ref{sec:developer-responsibility}.
% TODO_ unclear
Additionally, the library owner must be a session identifier (line 7) and not a participant, because a version identifier $(p,s,v)$ requires a session $s$ to be defined.
Finally, the nonce label must flow to the library owner \emph{at the current version} (line 8).
This is to ensure that the created nonce is readable at least in the current context.

However, the flowing relation is not enough to ensure that the nonce label is actually versioned. To do so, one would have to prove that the nonce label \emph{cannot} flow to the library owner (without version), as shown on this precondition:

\begin{gobra}
requires versionPerm > 0 ==>
    !tri.GetLabeling(l.Ctx()).CanFlow(l.Snapshot(), nonceLabel,
                               label.Readers(set[p.Id]{ l.Owner() }))
\end{gobra}

The problem is that such a condition is not trivial to verify in Gobra, which would require significant work for the developer each time they want to create a versioned value.
Therefore, we decided to not enforce this condition, as it is not necessary to ensure the soundness of the methodology.
If the developer “accidentally” creates a nonce with an unversioned label, but using strictly positive \texttt{versionPerm} (meant to be used for versioned values), they will not be prevented from doing so.
However, they will be bound by the constraints of the deletion mechanism. For now, it means that they will be forced to safely delete their unversioned nonce before the next increment of the session's version (but we will see in section \ref{sec:} that another way is possible).
Either way, this will just result in too tight constraints, but but does not call into question the soundness of the deletion mechanism.

Finally, the postcondition (line 10) states that the developer will receive the same amount of (strictly positive) permission of \texttt{receipt} as the amount of permission of \texttt{guard} consumed. This is indeed what was discussed in section \ref{sec:counting-permissions-idea}.

% TODO_ mention the convert function at some point, and explain that it justifies our choice

\subsection{Creating values with multiple versions for ratcheting}



\subsubsection{Key derivation functions}

\subsection{Deletion of versioned values}

\subsection{Increasing the version of a session}

\subsection{Encryption and decryption of versioned values}

