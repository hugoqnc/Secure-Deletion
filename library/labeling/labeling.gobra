package labeling

import arb "github.com/ModularVerification/ReusableVerificationLibrary/arbitrary"
import ev "github.com/ModularVerification/ReusableVerificationLibrary/event"
import "github.com/ModularVerification/ReusableVerificationLibrary/label"
import p "github.com/ModularVerification/ReusableVerificationLibrary/principal"
import tm "github.com/ModularVerification/ReusableVerificationLibrary/term"
import tr "github.com/ModularVerification/ReusableVerificationLibrary/trace"
import u "github.com/ModularVerification/ReusableVerificationLibrary/usage"
import . "github.com/ModularVerification/ReusableVerificationLibrary/usagecontext"


/** alias */
type IdSet = set[p.Id]

/** 
 * overview over some lemmas available in this file on the level of `canFlowInternal_DYStar
 * ghost
 * pure canFlowInternal_DYStar(corruptIds IdSet, l1, l2 label.SecrecyLabel) bool
 * 
 * ghost
 * ensures  canFlowInternal_DYStar(corruptIds, l, l)
 * canFlowInternalReflexive_DYStar(corruptIds IdSet, l label.SecrecyLabel)
 * 
 * ghost
 * ensures (canFlowInternal_DYStar(corruptIds, l1, l2) && canFlowInternal_DYStar(corruptIds, l2, l3)) ==> canFlowInternal_DYStar(corruptIds, l1, l3)
 * canFlowInternalTransitive_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel)
 * 
 * ghost
 * ensures  canFlowInternal_DYStar(corruptIds, l1, label.Public()) ==> canFlowInternal_DYStar(corruptIds, l1, l2)
 * flowsToPublicCanFlowInternal_DYStar(corruptIds IdSet, l1, l2 label.SecrecyLabel)
 * 
 * ghost
 * ensures  (canFlowInternal_DYStar(corruptIds, l2, label.Public()) && canFlowInternal_DYStar(corruptIds, l1, l2)) ==> canFlowInternal_DYStar(corruptIds, l1, label.Public())
 * canFlowFlowsToPublic_DYStar(corruptIds IdSet, l1, l2 label.SecrecyLabel)
 * 
 * ghost
 * requires l1.IsReaders() && l2.IsReaders()
 * requires label.GetReaders(l2) subset label.GetReaders(l1)
 * ensures canFlowInternal_DYStar(corruptIds, l1, l2)
 * canFlowInternalToSubsetReaders_DYStar(corruptIds IdSet, l1, l2 label.SecrecyLabel)
 * 
 * ghost
 * requires canFlowInternal_DYStar(corruptIds, l1, l3)
 * requires canFlowInternal_DYStar(corruptIds, l2, l3)
 * ensures  canFlowInternal_DYStar(corruptIds, label.Meet(l1, l2), l3)
 * canFlowInternalCreateMeetLhs_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel)
 * 
 * ghost
 * requires canFlowInternal_DYStar(corruptIds, label.Meet(l1, l2), l3)
 * ensures  canFlowInternal_DYStar(corruptIds, l1, l3)
 * ensures  canFlowInternal_DYStar(corruptIds, l2, l3)
 * canFlowInternalResolveMeetLhs_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel)
 * 
 * ghost
 * requires canFlowInternal_DYStar(corruptIds, l1, l2) || canFlowInternal_DYStar(corruptIds, l1, l3)
 * ensures  canFlowInternal_DYStar(corruptIds, l1, label.Meet(l2, l3))
 * canFlowInternalCreateMeetRhs_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel)
 * 
 * ghost
 * requires canFlowInternal_DYStar(corruptIds, l1, label.Meet(l2, l3))
 * requires canFlowInternal_DYStar(corruptIds, l2, l3)
 * ensures  canFlowInternal_DYStar(corruptIds, l1, l3)
 * canFlowInternalResolveMeetRhs_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel)
 * 
 * ghost
 * requires canFlowInternal_DYStar(corruptIds, l1, l3) || canFlowInternal_DYStar(corruptIds, l2, l3)
 * ensures  canFlowInternal_DYStar(corruptIds, label.Join(l1, l2), l3)
 * canFlowInternalCreateJoinLhs_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel)
 * 
 * ghost
 * requires canFlowInternal_DYStar(corruptIds, label.Join(l1, l1), l2)
 * ensures  canFlowInternal_DYStar(corruptIds, l1, l2)
 * canFlowInternalResolveJoinLhs_DYStar(corruptIds IdSet, l1, l2 label.SecrecyLabel)
 * 
 * ghost
 * requires canFlowInternal_DYStar(corruptIds, l1, l2)
 * requires canFlowInternal_DYStar(corruptIds, l1, l3)
 * ensures  canFlowInternal_DYStar(corruptIds, l1, label.Join(l2, l3))
 * canFlowInternalCreateJoinRhs_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel)
 * 
 * ghost
 * requires canFlowInternal_DYStar(corruptIds, l1, label.Join(l2, l3))
 * ensures  canFlowInternal_DYStar(corruptIds, l1, l2)
 * ensures  canFlowInternal_DYStar(corruptIds, l1, l3)
 * canFlowInternalResolveJoinRhs_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel)
 * 
 * ghost
 * requires canFlowInternal_DYStar(corruptIds, l1, label.Meet(l2, l3))
 * requires  l2FlowsToPublic ==> canFlowInternal_DYStar(corruptIds, l2, label.Public())
 * requires !l2FlowsToPublic ==> canFlowInternal_DYStar(corruptIds, l3, label.Public())
 * ensures   l2FlowsToPublic ==> canFlowInternal_DYStar(corruptIds, l1, l3)
 * ensures  !l2FlowsToPublic ==> canFlowInternal_DYStar(corruptIds, l1, l2)
 * canFlowInternalResolveMeetPublicRhs_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel, l2FlowsToPublic bool)
 * 
 * ghost
 * requires canFlowInternal_DYStar(corruptIds, l1, l2)
 * requires canFlowInternal_DYStar(corruptIds, l3, l4)
 * ensures  canFlowInternal_DYStar(corruptIds, label.Meet(l1, l3), label.Meet(l2, l4))
 * canFlowInternalCreateMeetBoth_DYStar(corruptIds IdSet, l1, l2, l3, l4 label.SecrecyLabel)
 * 
 * ghost
 * requires canFlowInternal_DYStar(corruptIds, l1, l2)
 * requires canFlowInternal_DYStar(corruptIds, l3, l4)
 * ensures  canFlowInternal_DYStar(corruptIds, label.Join(l1, l3), label.Join(l2, l4))
 * canFlowInternalCreateJoinBoth_DYStar(corruptIds IdSet, l1, l2, l3, l4 label.SecrecyLabel)
 */

type LabelingContext struct {
    usage UsageContext
}

ghost
decreases
pure func (ctx LabelingContext) Props() bool {
    return ctx.usage != nil
}

// TODO make ghost
decreases
pure func GetLabelingContext(usage UsageContext) (res LabelingContext) {
    return LabelingContext{ usage }
}

ghost
decreases tm.getTermHeight(term)
requires ctx.Props()
pure func (ctx LabelingContext) IsValid(t tr.TraceEntry, term tm.Term) bool {
    return (term.IsInteger64() ==> true) &&
        (term.IsInteger32() ==> true) &&
        (term.IsConst1() ==> true) &&
        (term.IsString() ==> true) &&
        (term.IsZeroString() ==> true) &&
        (term.IsInfo() ==> true) &&
        (term.IsPrologue() ==> true) &&
        (term.IsGenerator() ==> true) &&
        (term.IsPk() ==> ctx.IsValid(t, tm.getSk(term))) &&
        (term.IsEncrypt() ==>
            ctx.IsValidEncryptInternal(t, tm.getPk(term), tm.getPlaintext(term), ctx.GetLabel(tm.getPlaintext(term)), true)) &&
        (term.IsAead() ==>
            ctx.IsValidAeadInternal(t, tm.getAeadKey(term), tm.getAeadNonce(term), tm.getPlaintext(term), ctx.GetLabel(tm.getPlaintext(term)), tm.getAuthtext(term), true)) &&
        (term.IsRandom() ==>
            // `nonceOccurs` saves us from writing yet another function to simply state that `term` is on the trace
            t.OnlyNonceOccurs(term)) &&
        (term.IsExp() ==> exists base, e tm.Term :: { tm.exp(base, e) } term == tm.exp(base, e) && ctx.IsValid(t, base) && ctx.IsValid(t, e)) &&
        ((term.IsHash() || term.IsKdf1() || term.IsKdf2() || term.IsKdf3()) ==> ctx.IsValid(t, tm.getInput(term))) &&
        (term.IsKdfRatchet() ==> ctx.IsValid(t, tm.getInput(term)) && ctx.IsValid(t, tm.getInput2(term))) && 
        (term.IsTuple() ==> forall i int :: { tm.getTupleElem(term, i) } 0 <= i && i < term.GetTupleArity() ==> ctx.IsValid(t, tm.getTupleElem(term, i))) &&
        (term.IsSignature() ==>
            ctx.IsValidSignatureInternal(t, tm.getPlaintext(term), tm.getSk(term), true))
}

ghost
decreases
requires ctx.Props()
requires ctx.GetLabel(plaintext) == plaintextLabel
pure func (ctx LabelingContext) IsValidEncrypt(t tr.TraceEntry, pk, plaintext tm.Term, plaintextLabel label.SecrecyLabel) bool {
    return ctx.IsValidEncryptInternal(t, pk, plaintext, plaintextLabel, true)
}

ghost
decreases tm.getTermHeight(tm.encrypt(plaintext, pk)), mutualRecursionTrick
requires ctx.Props()
requires ctx.GetLabel(plaintext) == plaintextLabel
/**
  * `IsValidEncryptInternal` is used with a fake argument to over-come a common limitation in proving termination for
  * mutally recursive calls. `IsValidEncrypt` provides a wrapper that hides these internal details.
  */
pure func (ctx LabelingContext) IsValidEncryptInternal(t tr.TraceEntry, pk, plaintext tm.Term, plaintextLabel label.SecrecyLabel, mutualRecursionTrick bool) bool {
    return ctx.IsValid(t, pk) &&
        ctx.IsValid(t, plaintext) &&
        // message has to flow to secrecy label of secret key
        ctx.CanFlow(t, plaintextLabel, ctx.GetSkLabel(pk)) &&
        (
            // either the plaintext is public ...
            ctx.CanFlow(t, plaintextLabel, label.Public()) ||
            // ... or pkePred holds
            (
                pk.IsPk() &&
                ctx.IsPkeKey(tm.getSk(pk)) &&
                ctx.usage.PkePred(t, u.GetUsageString(get(ctx.GetUsage(tm.getSk(pk)))), plaintext, pk)))
}

ghost
decreases
requires ctx.Props()
requires ctx.GetLabel(plaintext) == plaintextLabel
pure func (ctx LabelingContext) IsValidAead(t tr.TraceEntry, key, nonce, plaintext tm.Term, plaintextLabel label.SecrecyLabel, authtext tm.Term) bool {
    return ctx.IsValidAeadInternal(t, key, nonce, plaintext, plaintextLabel, authtext, true)
}

ghost
decreases tm.getTermHeight(tm.aead(key, nonce, plaintext, authtext)), mutualRecursionTrick
requires ctx.Props()
requires ctx.GetLabel(plaintext) == plaintextLabel
/**
  * `IsValidAeadInternal` is used with a fake argument to over-come a common limitation in proving termination for
  * mutally recursive calls. `IsValidAead` provides a wrapper that hides these internal details.
  */
pure func (ctx LabelingContext) IsValidAeadInternal(t tr.TraceEntry, key, nonce, plaintext tm.Term, plaintextLabel label.SecrecyLabel, authtext tm.Term, mutualRecursionTrick bool) bool {
    return ctx.IsValid(t, key) &&
        ctx.IsValid(t, nonce) &&
        ctx.IsValid(t, plaintext) &&
        ctx.IsValid(t, authtext) &&
        // nonce and authtext have to flow to public
        ctx.CanFlow(t, ctx.GetLabel(nonce), label.Public()) &&
        ctx.CanFlow(t, ctx.GetLabel(authtext), label.Public()) &&
        (
            // either key and message are public...
            (ctx.CanFlow(t, ctx.GetLabel(key), label.Public()) &&
                ctx.CanFlow(t, plaintextLabel, label.Public())) ||
            // ... or message can flow to key's label and AeadPred holds
            (ctx.CanFlow(t, plaintextLabel, ctx.GetLabel(key)) &&
                ctx.HasAeadKeyUsage(key) &&
                ctx.usage.AeadPred(t, u.GetUsageString(get(ctx.GetUsage(key))), key, nonce, plaintext, authtext)))
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) IsValidSignature(t tr.TraceEntry, msg, sk tm.Term) bool {
    return ctx.IsValidSignatureInternal(t, msg, sk, true)
}

ghost
decreases tm.getTermHeight(tm.sign(msg, sk)), mutualRecursionTrick
requires ctx.Props()
pure func (ctx LabelingContext) IsValidSignatureInternal(t tr.TraceEntry, msg, sk tm.Term, mutualRecursionTrick bool) bool {
    return ctx.IsValid(t, msg) &&
        ctx.IsValid(t, sk) &&
        ctx.CanFlow(t, ctx.GetLabel(msg), label.Public()) && // since msg can be extracted from signature
        (
            // either the secret key is public ...
            ctx.CanFlow(t, ctx.GetLabel(sk), label.Public()) ||
            // ... or SignPred holds
            (
                ctx.IsSigningKey(sk) &&
                ctx.usage.SignPred(t, u.GetUsageString(get(ctx.GetUsage(sk))), msg, sk)))
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) IsAeadKey(t tr.TraceEntry, key tm.Term, keyL label.SecrecyLabel, usageString string) bool {
    return ctx.IsSecretRelaxed(t, key, keyL, u.AeadKey(usageString))
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) IsSignKey(t tr.TraceEntry, key tm.Term, skOwner p.Id, usageString string) bool {
    return ctx.IsSecretRelaxed(t, key, label.Readers(set[p.Id]{ skOwner }), u.SigningKey(usageString))
}

ghost
decreases tm.getTermHeight(term)
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsValid(t1, term)
ensures  ctx.IsValid(t2, term)
func (ctx LabelingContext) IsValidMonotonic(t1, t2 tr.TraceEntry, term tm.Term) {
    if (term.IsRandom()) {
        t1.OnlyNonceOccursMonotonic(t2, term)
    } else if (term.IsPk()) {
        ctx.IsValidMonotonic(t1, t2, tm.getSk(term))
    } else if (term.IsEncrypt()) {
        pk := tm.getPk(term)
        plaintext := tm.getPlaintext(term)
        ctx.IsValidEncryptMonotonic(t1, t2, pk, plaintext, ctx.GetLabel(plaintext), true)
    } else if term.IsAead() {
        key := tm.getAeadKey(term)
        nonce := tm.getAeadNonce(term)
        plaintext := tm.getPlaintext(term)
        authtext := tm.getAuthtext(term)
        ctx.IsValidAeadMonotonic(t1, t2, key, nonce, plaintext, ctx.GetLabel(plaintext), authtext, true)
    } else if term.IsExp() {
        assert exists base, e tm.Term :: { tm.exp(base, e) } term == tm.exp(base, e) && ctx.IsValid(t1, base) && ctx.IsValid(t1, e)
        base, e := arb.GetArbTerm(), arb.GetArbTerm()
        assume term == tm.exp(base, e) && ctx.IsValid(t1, base) && ctx.IsValid(t1, e)
        ctx.IsValidMonotonic(t1, t2, base)
        ctx.IsValidMonotonic(t1, t2, e)
    } else if (term.IsHash() || term.IsKdf1() || term.IsKdf2() || term.IsKdf3()) {
        ctx.IsValidMonotonic(t1, t2, tm.getInput(term))
    } else if term.IsKdfRatchet() {
         ctx.IsValidMonotonic(t1, t2, tm.getInput(term))
          ctx.IsValidMonotonic(t1, t2, tm.getInput2(term))
    } else if term.IsTuple() {
        invariant 0 <= i && i <= term.GetTupleArity()
        invariant forall j int :: { tm.getTupleElem(term, j) } 0 <= j && j < term.GetTupleArity() ==> ctx.IsValid(t1, tm.getTupleElem(term, j))
        invariant forall j int :: { tm.getTupleElem(term, j) } 0 <= j && j < i ==> ctx.IsValid(t2, tm.getTupleElem(term, j))
        decreases term.GetTupleArity() - i
        for i := 0; i < term.GetTupleArity(); i++ {
            ctx.IsValidMonotonic(t1, t2, tm.getTupleElem(term, i))
        }
    } else if term.IsSignature() {
        sk := tm.getSk(term)
        plaintext := tm.getPlaintext(term)
        ctx.IsValidSignatureMonotonic(t1, t2, plaintext, sk, true)
    }
}

ghost
decreases tm.getTermHeight(tm.encrypt(plaintext, pk)), mutualRecursionTrick
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.GetLabel(plaintext) == plaintextLabel
requires ctx.IsValidEncrypt(t1, pk, plaintext, plaintextLabel)
ensures  ctx.IsValidEncrypt(t2, pk, plaintext, plaintextLabel)
func (ctx LabelingContext) IsValidEncryptMonotonic(t1, t2 tr.TraceEntry, pk, plaintext tm.Term, plaintextLabel label.SecrecyLabel, mutualRecursionTrick bool) {
    ctx.IsValidMonotonic(t1, t2, pk)
    ctx.IsValidMonotonic(t1, t2, plaintext)
    skLabel := ctx.GetSkLabel(pk)
    ctx.CanFlowMonotonic(t1, t2, plaintextLabel, skLabel)
    if (ctx.CanFlow(t1, plaintextLabel, label.Public())) {
        ctx.CanFlowMonotonic(t1, t2, plaintextLabel, label.Public())
    } else {
        ctx.usage.PkePredMonotonic(t1, t2, u.GetUsageString(get(ctx.GetUsage(tm.getSk(pk)))), plaintext, pk)
    }
}

ghost
decreases tm.getTermHeight(tm.aead(key, nonce, plaintext, authtext)), mutualRecursionTrick
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.GetLabel(plaintext) == plaintextLabel
requires ctx.IsValidAead(t1, key, nonce, plaintext, plaintextLabel, authtext)
ensures  ctx.IsValidAead(t2, key, nonce, plaintext, plaintextLabel, authtext)
func (ctx LabelingContext) IsValidAeadMonotonic(t1, t2 tr.TraceEntry, key, nonce, plaintext tm.Term, plaintextLabel label.SecrecyLabel, authtext tm.Term, mutualRecursionTrick bool) {
    ctx.IsValidMonotonic(t1, t2, key)
    ctx.IsValidMonotonic(t1, t2, nonce)
    ctx.IsValidMonotonic(t1, t2, plaintext)
    ctx.IsValidMonotonic(t1, t2, authtext)
    ctx.CanFlowMonotonic(t1, t2, ctx.GetLabel(nonce), label.Public())
    ctx.CanFlowMonotonic(t1, t2, ctx.GetLabel(authtext), label.Public())
    if (ctx.CanFlow(t1, ctx.GetLabel(key), label.Public()) &&
        ctx.CanFlow(t1, plaintextLabel, label.Public())) {
        ctx.CanFlowMonotonic(t1, t2, ctx.GetLabel(key), label.Public())
        ctx.CanFlowMonotonic(t1, t2, plaintextLabel, label.Public())
    } else {
        ctx.CanFlowMonotonic(t1, t2, plaintextLabel, ctx.GetLabel(key))
        usageCtx := ctx.GetUsage(key)
        ctx.usage.AeadPredMonotonic(t1, t2, u.GetUsageString(get(usageCtx)), key, nonce, plaintext, authtext)
    }
}

ghost
decreases tm.getTermHeight(tm.sign(msg, sk)), mutualRecursionTrick
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsValidSignature(t1, msg, sk)
ensures  ctx.IsValidSignature(t2, msg, sk)
func (ctx LabelingContext) IsValidSignatureMonotonic(t1, t2 tr.TraceEntry, msg, sk tm.Term, mutualRecursionTrick bool) {
    ctx.IsValidMonotonic(t1, t2, msg)
    ctx.IsValidMonotonic(t1, t2, sk)
    ctx.CanFlowMonotonic(t1, t2, ctx.GetLabel(msg), label.Public())
    if ctx.CanFlow(t1, ctx.GetLabel(sk), label.Public()) {
        ctx.CanFlowMonotonic(t1, t2, ctx.GetLabel(sk), label.Public())
    } else {
        usageCtx := ctx.GetUsage(sk)
        ctx.usage.SignPredMonotonic(t1, t2, u.GetUsageString(get(usageCtx)), msg, sk)
    }
}

ghost
decreases
requires ctx.Props()
/** expresses that a term is valid and that its label is `l` */
pure func (ctx LabelingContext) IsLabeled(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) bool {
    return ctx.IsValid(t, term) &&
        ctx.GetLabel(term) == l
}

ghost
decreases
requires ctx.Props()
/** expresses that a term is valid and that `l` flows to its label */
pure func (ctx LabelingContext) IsLabeledRelaxed(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) bool {
    return ctx.IsValid(t, term) &&
        ctx.CanFlow(t, l, ctx.GetLabel(term))
}

ghost
decreases
requires ctx.Props()
/** expresses that a term is valid and that `l` flows to its label and back */
pure func (ctx LabelingContext) IsLabeledPrecise(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) bool {
    return ctx.IsValid(t, term) &&
        ctx.CanFlow(t, l, ctx.GetLabel(term)) &&
        ctx.CanFlow(t, ctx.GetLabel(term), l)
}

ghost
decreases
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsLabeled(t1, term, l)
ensures  ctx.IsLabeled(t2, term, l)
func (ctx LabelingContext) IsLabeledMonotonic(t1, t2 tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    ctx.IsValidMonotonic(t1, t2, term)
}

ghost
decreases
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsLabeledRelaxed(t1, term, l)
ensures  ctx.IsLabeledRelaxed(t2, term, l)
func (ctx LabelingContext) IsLabeledRelaxedMonotonic(t1, t2 tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    ctx.IsValidMonotonic(t1, t2, term)
    ctx.CanFlowMonotonic(t1, t2, l, ctx.GetLabel(term))
}

ghost
decreases
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsLabeledPrecise(t1, term, l)
ensures  ctx.IsLabeledPrecise(t2, term, l)
func (ctx LabelingContext) IsLabeledPreciseMonotonic(t1, t2 tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    ctx.IsValidMonotonic(t1, t2, term)
    ctx.CanFlowMonotonic(t1, t2, l, ctx.GetLabel(term))
    ctx.CanFlowMonotonic(t1, t2, ctx.GetLabel(term), l)
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) IsSecret(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel, usage u.Usage) bool {
    return ctx.IsLabeled(t, term, l) &&
        ctx.GetUsage(term) == some(usage)
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) IsSecretRelaxed(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel, usage u.Usage) bool {
    return ctx.IsLabeledRelaxed(t, term, l) &&
        ctx.GetUsage(term) == some(usage)
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) IsSecretPrecise(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel, usage u.Usage) bool {
    return ctx.IsLabeledPrecise(t, term, l) &&
        ctx.GetUsage(term) == some(usage)
}

ghost
decreases
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsSecret(t1, term, l, usage)
ensures  ctx.IsSecret(t2, term, l, usage)
func (ctx LabelingContext) IsSecretMonotonic(t1, t2 tr.TraceEntry, term tm.Term, l label.SecrecyLabel, usage u.Usage) {
    ctx.IsLabeledMonotonic(t1, t2, term, l)
}

ghost
decreases
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsSecretRelaxed(t1, term, l, usage)
ensures  ctx.IsSecretRelaxed(t2, term, l, usage)
func (ctx LabelingContext) IsSecretRelaxedMonotonic(t1, t2 tr.TraceEntry, term tm.Term, l label.SecrecyLabel, usage u.Usage) {
    ctx.IsLabeledRelaxedMonotonic(t1, t2, term, l)
}

ghost
decreases tm.getTermHeight(term)
requires ctx.Props()
ensures term.IsInteger64() ==> res == label.Public()
ensures term.IsInteger32() ==> res == label.Public()
ensures term.IsConst1() ==> res == label.Public()
ensures term.IsString() ==> res == label.Public()
ensures term.IsZeroString() ==> res == label.Public()
ensures term.IsInfo() ==> res == label.Public()
ensures term.IsPrologue() ==> res == label.Public()
ensures term.IsGenerator() ==> res == label.Public()
ensures term.IsPk() ==> res == label.Public()
ensures term.IsEncrypt() ==> res == label.Public()
ensures term.IsAead() ==> res == label.Public()
ensures term.IsRandom() ==> res == tm.getRandomLabel(term)
// hash, kdf1, kdf2, kdf3 and kdfRatchet are considered one-way functions
// hashes are considered to be fine for sending them to the network
// the result of applying a KDF function however is used as a key and therefore, we want to have the
// tightest label that is possible, which is simply the label of its parameter.
// any more generic label (e.g. even public()) would still be sound but we weaken any secrecy property
// as we would consider an unnecessarily big set of participants of which any could be corrupted and
// thus the secrecy lemma holds trivially
ensures term.IsHash() ==> res == label.Public()
ensures (term.IsKdf1() || term.IsKdf2() || term.IsKdf3()) ==> res == ctx.GetLabel(tm.getInput(term))
ensures forall key, DhSharedSecret tm.Term :: { tm.kdfRatchet(key, DhSharedSecret) } term == tm.kdfRatchet(key, DhSharedSecret) ==> res == ctx.GetLabel(DhSharedSecret)
ensures term.IsTuple() ==> res == ctx.nestedMeetInternal(term, getTupleSeq(term), 0, true) // intersection of audience is allowed to read
// DH exponentiation is special cased:
// if a term is `(g^x)^y` or equivalently `g^(x*y)` it results in the join label of x and y
// i.e. the DH key can be read by all readers of x and y (set union) since it's sufficient
// to either know x or y as the public key is public.
// note that one must make sure the postconditions to not specify multiple labels for the same term, which
// would immediately be a contradiction. Thus, the case where t1 is an exponent of the generator and another term `e1` has to be explicitly excluded
// as this case is already covered via `mult`, i.e. (g^e1)^t2 == g^(e1 * t2)
ensures forall t1, t2 tm.Term :: { tm.mult(t1, t2) } term == tm.mult(t1, t2) ==> res == label.Join(ctx.GetLabel(t1), ctx.GetLabel(t2))
ensures forall t1, t2 tm.Term :: { tm.exp(t1, t2) } term == tm.exp(t1, t2) ==>
    (t1.IsGenerator() && t2.IsRandom() ? res == label.Public() :
        t1.IsGenerator() /* && !t2.IsRandom() */ ? res == ctx.GetLabel(t2) :
            !(exists e1 tm.Term :: { tm.exp(tm.generator(), e1) } t1 == tm.exp(tm.generator(), e1)) ==> res == label.Meet(ctx.GetLabel(t1), ctx.GetLabel(t2)))
ensures forall msg, sk tm.Term :: { tm.sign(msg, sk) } term == tm.sign(msg, sk) ==> res == ctx.GetLabel(msg)
/**
  * WARNING:
  * 2 terms that are equal based on the equational theory must return the same label!
  */
pure func (ctx LabelingContext) GetLabel(term tm.Term) (res label.SecrecyLabel)


ghost
decreases
requires t.IsTuple()
ensures  len(res) == t.GetTupleArity()
ensures  forall i int :: 0 <= i && i < t.GetTupleArity() ==> res[i] == tm.getTupleElem(t, i) && tm.getTermHeight(res[i]) < tm.getTermHeight(t)
pure func getTupleSeq(t tm.Term) (res seq[tm.Term]) {
    return t.IsTuple2() ? seq[tm.Term]{ tm.getTupleElem(t, 0), tm.getTupleElem(t, 1) } :
            t.IsTuple3() ? seq[tm.Term]{ tm.getTupleElem(t, 0), tm.getTupleElem(t, 1), tm.getTupleElem(t, 2) } :
            t.IsTuple4() ? seq[tm.Term]{ tm.getTupleElem(t, 0), tm.getTupleElem(t, 1), tm.getTupleElem(t, 2), tm.getTupleElem(t, 3) } :
            t.IsTuple5() ? seq[tm.Term]{ tm.getTupleElem(t, 0), tm.getTupleElem(t, 1), tm.getTupleElem(t, 2), tm.getTupleElem(t, 3), tm.getTupleElem(t, 4) } :
            // t.IsTuple6() ? seq[tm.Term]{ tm.getTupleElem(t, 0), tm.getTupleElem(t, 1), tm.getTupleElem(t, 2), tm.getTupleElem(t, 3), tm.getTupleElem(t, 4), tm.getTupleElem(t, 5) } :
                seq[tm.Term]{ tm.getTupleElem(t, 0), tm.getTupleElem(t, 1), tm.getTupleElem(t, 2), tm.getTupleElem(t, 3), tm.getTupleElem(t, 4), tm.getTupleElem(t, 5), tm.getTupleElem(t, 6) }
}

ghost
decreases
requires ctx.Props() && t.IsTuple() && terms == getTupleSeq(t)
requires 0 <= startIdx && startIdx + 2 <= len(terms)
pure func (ctx LabelingContext) nestedMeet(t tm.Term, terms seq[tm.Term], startIdx int) label.SecrecyLabel {
    return ctx.nestedMeetInternal(t, terms, startIdx, true)
}

ghost
decreases tm.getTermHeight(t), len(terms) - startIdx, mutualRecursionTrick
requires ctx.Props() && t.IsTuple() && terms == getTupleSeq(t)
requires 0 <= startIdx && startIdx + 2 <= len(terms)
pure func (ctx LabelingContext) nestedMeetInternal(t tm.Term, terms seq[tm.Term], startIdx int, mutualRecursionTrick bool) label.SecrecyLabel {
    return startIdx + 2 == len(terms) ? label.Meet(ctx.GetLabel(terms[startIdx]), ctx.GetLabel(terms[startIdx + 1])) :
            label.Meet(ctx.GetLabel(terms[startIdx]), ctx.nestedMeetInternal(t, terms, startIdx + 1, mutualRecursionTrick))
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) GetUsage(t tm.Term) option[u.Usage] {
    return ctx.usage.GetUsage(t)
}

ghost
decreases
requires ctx.Props()
/** wrapper to get and check usage of a term for convenience */
pure func (ctx LabelingContext) IsPkeKey(sk tm.Term) bool {
    return (ctx.GetUsage(sk) != none[u.Usage]) && (get(ctx.GetUsage(sk))).IsPkeKey()
}

ghost
decreases
requires ctx.Props()
/** wrapper to get and check usage of a term for convenience */
pure func (ctx LabelingContext) IsSigningKey(sk tm.Term) bool {
    return (ctx.GetUsage(sk) != none[u.Usage]) && (get(ctx.GetUsage(sk))).IsSigningKey()
}

ghost
decreases
requires ctx.Props()
/** wrapper to get and check usage of a term for convenience */
pure func (ctx LabelingContext) HasAeadKeyUsage(key tm.Term) bool {
    return (ctx.GetUsage(key) != none[u.Usage]) && (get(ctx.GetUsage(key))).IsAeadKey()
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) IsMsg(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) bool {
    return ctx.IsValid(t, term) &&
        ctx.CanFlow(t, ctx.GetLabel(term), l)
}

ghost
decreases
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsMsg(t1, term, l)
ensures  ctx.IsMsg(t2, term, l)
func (ctx LabelingContext) IsMsgMonotonic(t1, t2 tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    ctx.IsValidMonotonic(t1, t2, term)
    ctx.CanFlowMonotonic(t1, t2, ctx.GetLabel(term), l)
}

ghost
decreases
requires ctx.Props()
requires ctx.CanFlow(t, l1, l2)
requires ctx.IsMsg(t, term, l1)
ensures  ctx.IsMsg(t, term, l2)
func (ctx LabelingContext) IsMsgTransitive(t tr.TraceEntry, term tm.Term, l1, l2 label.SecrecyLabel) {
    ctx.CanFlowTransitive(t, ctx.GetLabel(term), l1, l2)
}

ghost
decreases
requires ctx.Props()
requires term.IsTuple()
requires forall i int :: { tm.getTupleElem(term, i) } 0 <= i && i < term.GetTupleArity() ==> ctx.IsMsg(t, tm.getTupleElem(term, i), l)
ensures  ctx.IsMsg(t, term, l)
/** lemma for tuples having same label */
func (ctx LabelingContext) IsMsgTupleCreate(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    n := term.GetTupleArity()
    subterms := getTupleSeq(term)
    secondToLastT := subterms[n-2]
    secondToLastL := ctx.GetLabel(secondToLastT)
    lastT := subterms[n-1]
    lastL := ctx.GetLabel(lastT)
    ctx.CanFlowCreateMeetLhs(t, secondToLastL, lastL, l)
    prevLabel := ctx.nestedMeet(term, subterms, n - 2)

    invariant 0 <= i && i <= n - 2
    invariant len(getTupleSeq(term)) == n
    invariant prevLabel == ctx.nestedMeet(term, subterms, i)
    invariant ctx.CanFlow(t, prevLabel, l)
    decreases i
    for i := n - 2; i >= 1; i-- {
        curT := subterms[i-1]
        curL := ctx.GetLabel(curT)
        ctx.CanFlowCreateMeetLhs(t, curL, prevLabel, l)
        prevLabel = label.Meet(curL, prevLabel)
    }
   
    firstL := ctx.GetLabel(tm.getTupleElem(term, 0))
    ctx.CanFlowReflexive(t, l)
    ctx.CanFlowCreateMeetLhs(t, firstL, l, l)
}

ghost
decreases
requires ctx.Props()
requires term.IsTuple()
requires ctx.IsMsg(t, term, l)
ensures  forall i int :: { tm.getTupleElem(term, i) } 0 <= i && i < term.GetTupleArity() ==> ctx.IsMsg(t, tm.getTupleElem(term, i), l)
/** lemma for tuples flowing to some label */
func (ctx LabelingContext) IsMsgTupleResolve(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    n := term.GetTupleArity()
    subterms := getTupleSeq(term)

    invariant 0 <= i && i <= n - 2
    invariant len(getTupleSeq(term)) == n
    invariant ctx.CanFlow(t, ctx.nestedMeet(term, subterms, i), l)
    invariant forall j int :: { tm.getTupleElem(term, j) } 0 <= j && j < i ==> ctx.IsMsg(t, tm.getTupleElem(term, j), l)
    decreases n - i
    for i := 0; i < n - 2; i++ {
        curT := tm.getTupleElem(term, i)
        curL := ctx.GetLabel(curT)
        remL := ctx.nestedMeet(term, subterms, i + 1)
        ctx.CanFlowResolveMeetLhs(t, curL, remL, l)
    }
    secondToLastT := tm.getTupleElem(term, n - 2)
    secondToLastL := ctx.GetLabel(secondToLastT)
    lastT := tm.getTupleElem(term, n - 1)
    lastL := ctx.GetLabel(lastT)
    ctx.CanFlowResolveMeetLhs(t, secondToLastL, lastL, l)
}

ghost
decreases
requires ctx.CanFlow(t, l1, l3)
requires ctx.CanFlow(t, l2, l3)
ensures  ctx.CanFlow(t, label.Meet(l1, l2), l3)
func (ctx LabelingContext) CanFlowCreateMeetLhs(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalCreateMeetLhs(t.getCorruptIds(), l1, l2, l3)
}

ghost
decreases
requires ctx.canFlowInternal(corruptIds, l1, l3)
requires ctx.canFlowInternal(corruptIds, l2, l3)
ensures  ctx.canFlowInternal(corruptIds, label.Meet(l1, l2), l3)
func (ctx LabelingContext) canFlowInternalCreateMeetLhs(corruptIds set[p.Id], l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l3)
    ctx.canFlowInternalImpliesDYStar(corruptIds, l2, l3)
    ctx.canFlowInternalCreateMeetLhs_DYStar(corruptIds, l1, l2, l3)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, label.Meet(l1, l2), l3)
}

ghost
decreases
requires ctx.canFlowInternal_DYStar(corruptIds, l1, l3)
requires ctx.canFlowInternal_DYStar(corruptIds, l2, l3)
ensures  ctx.canFlowInternal_DYStar(corruptIds, label.Meet(l1, l2), l3)
func (ctx LabelingContext) canFlowInternalCreateMeetLhs_DYStar(corruptIds set[p.Id], l1, l2, l3 label.SecrecyLabel) {
    // no body needed
}

ghost
decreases
requires ctx.CanFlow(t, label.Meet(l1, l2), l3)
ensures  ctx.CanFlow(t, l1, l3)
ensures  ctx.CanFlow(t, l2, l3)
func (ctx LabelingContext) CanFlowResolveMeetLhs(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalResolveMeetLhs(t.getCorruptIds(), l1, l2, l3)
}

ghost
decreases
requires ctx.canFlowInternal(corruptIds, label.Meet(l1, l2), l3)
ensures  ctx.canFlowInternal(corruptIds, l1, l3)
ensures  ctx.canFlowInternal(corruptIds, l2, l3)
func (ctx LabelingContext) canFlowInternalResolveMeetLhs(corruptIds set[p.Id], l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalImpliesDYStar(corruptIds, label.Meet(l1, l2), l3)
    ctx.canFlowInternalResolveMeetLhs_DYStar(corruptIds, l1, l2, l3)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l3)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l2, l3)
}

ghost
decreases label.GetHeight(l3)
requires ctx.canFlowInternal_DYStar(corruptIds, label.Meet(l1, l2), l3)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, l3)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l2, l3)
func (ctx LabelingContext) canFlowInternalResolveMeetLhs_DYStar(corruptIds set[p.Id], l1, l2, l3 label.SecrecyLabel) {
    if (l3.IsMeet() || l3.IsJoin()) {
        if (ctx.canFlowInternal_DYStar(corruptIds, label.Meet(l1, l2), label.GetFirstLabel(l3))) {
            ctx.canFlowInternalResolveMeetLhs_DYStar(corruptIds, l1, l2, label.GetFirstLabel(l3))
        }
        if (ctx.canFlowInternal_DYStar(corruptIds, label.Meet(l1, l2), label.GetSecondLabel(l3))) {
            ctx.canFlowInternalResolveMeetLhs_DYStar(corruptIds, l1, l2, label.GetSecondLabel(l3))
        }
    }
}

ghost
decreases
requires ctx.CanFlow(t, l1, l2) || ctx.CanFlow(t, l1, l3)
ensures  ctx.CanFlow(t, l1, label.Meet(l2, l3))
func (ctx LabelingContext) CanFlowCreateMeetRhs(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalCreateMeetRhs(t.getCorruptIds(), l1, l2, l3)
}

ghost
decreases
requires ctx.canFlowInternal(corruptIds, l1, l2) || ctx.canFlowInternal(corruptIds, l1, l3)
ensures  ctx.canFlowInternal(corruptIds, l1, label.Meet(l2, l3))
func (ctx LabelingContext) canFlowInternalCreateMeetRhs(corruptIds set[p.Id], l1, l2, l3 label.SecrecyLabel) {
    if ctx.canFlowInternal(corruptIds, l1, l2) {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l2)
    }
    if ctx.canFlowInternal(corruptIds, l1, l3) {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l3)
    }
    ctx.canFlowInternalCreateMeetRhs_DYStar(corruptIds, l1, l2, l3)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, label.Meet(l2, l3))
}

ghost
decreases
requires ctx.canFlowInternal_DYStar(corruptIds, l1, l2) || ctx.canFlowInternal_DYStar(corruptIds, l1, l3)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, label.Meet(l2, l3))
func (ctx LabelingContext) canFlowInternalCreateMeetRhs_DYStar(corruptIds set[p.Id], l1, l2, l3 label.SecrecyLabel) {
    // no body needed
}

ghost
decreases
requires ctx.CanFlow(t, l1, l2)
requires ctx.CanFlow(t, l3, l4)
ensures  ctx.CanFlow(t, label.Meet(l1, l3), label.Meet(l2, l4))
func (ctx LabelingContext) CanFlowCreateMeetBoth(t tr.TraceEntry, l1, l2, l3, l4 label.SecrecyLabel) {
    ctx.canFlowInternalCreateMeetBoth(t.getCorruptIds(), l1, l2, l3, l4)
}

ghost
decreases
requires ctx.canFlowInternal(corruptIds, l1, l2)
requires ctx.canFlowInternal(corruptIds, l3, l4)
ensures  ctx.canFlowInternal(corruptIds, label.Meet(l1, l3), label.Meet(l2, l4))
func (ctx LabelingContext) canFlowInternalCreateMeetBoth(corruptIds set[p.Id], l1, l2, l3, l4 label.SecrecyLabel) {
    ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l2)
    ctx.canFlowInternalImpliesDYStar(corruptIds, l3, l4)
    ctx.canFlowInternalCreateMeetBoth_DYStar(corruptIds, l1, l2, l3, l4)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, label.Meet(l1, l3), label.Meet(l2, l4))
}

ghost
decreases
requires ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
requires ctx.canFlowInternal_DYStar(corruptIds, l3, l4)
ensures  ctx.canFlowInternal_DYStar(corruptIds, label.Meet(l1, l3), label.Meet(l2, l4))
func (ctx LabelingContext) canFlowInternalCreateMeetBoth_DYStar(corruptIds set[p.Id], l1, l2, l3, l4 label.SecrecyLabel) {
    ctx.canFlowInternalCreateMeetRhs_DYStar(corruptIds, l1, l2, l4)
    ctx.canFlowInternalCreateMeetRhs_DYStar(corruptIds, l3, l2, l4)
}

ghost
decreases
requires ctx.CanFlow(t, l1, l2)
requires ctx.CanFlow(t, l3, l4)
ensures  ctx.CanFlow(t, label.Join(l1, l3), label.Join(l2, l4))
func (ctx LabelingContext) CanFlowCreateJoinBoth(t tr.TraceEntry, l1, l2, l3, l4 label.SecrecyLabel) {
    ctx.canFlowInternalCreateJoinBoth(t.getCorruptIds(), l1, l2, l3, l4)
}

ghost
decreases
requires ctx.canFlowInternal(corruptIds, l1, l2)
requires ctx.canFlowInternal(corruptIds, l3, l4)
ensures  ctx.canFlowInternal(corruptIds, label.Join(l1, l3), label.Join(l2, l4))
func (ctx LabelingContext) canFlowInternalCreateJoinBoth(corruptIds IdSet, l1, l2, l3, l4 label.SecrecyLabel) {
    ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l2)
    ctx.canFlowInternalImpliesDYStar(corruptIds, l3, l4)
    ctx.canFlowInternalCreateJoinBoth_DYStar(corruptIds, l1, l2, l3, l4)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, label.Join(l1, l3), label.Join(l2, l4))
}

ghost
decreases
requires ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
requires ctx.canFlowInternal_DYStar(corruptIds, l3, l4)
ensures  ctx.canFlowInternal_DYStar(corruptIds, label.Join(l1, l3), label.Join(l2, l4))
func (ctx LabelingContext) canFlowInternalCreateJoinBoth_DYStar(corruptIds IdSet, l1, l2, l3, l4 label.SecrecyLabel) {
    ctx.canFlowInternalCreateJoinLhs_DYStar(corruptIds, l1, l3, l2)
    ctx.canFlowInternalCreateJoinLhs_DYStar(corruptIds, l1, l3, l4)
}

ghost
decreases
requires ctx.CanFlow(t, l1, label.Meet(l2, l3))
requires ctx.CanFlow(t, l2, l3)
ensures  ctx.CanFlow(t, l1, l3)
func (ctx LabelingContext) CanFlowResolveMeetRhs(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalResolveMeetRhs(t.getCorruptIds(), l1, l2, l3)
}

ghost
decreases
requires ctx.canFlowInternal(corruptIds, l1, label.Meet(l2, l3))
requires ctx.canFlowInternal(corruptIds, l2, l3)
ensures  ctx.canFlowInternal(corruptIds, l1, l3)
func (ctx LabelingContext) canFlowInternalResolveMeetRhs(corruptIds set[p.Id], l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalImpliesDYStar(corruptIds, l1, label.Meet(l2, l3))
    ctx.canFlowInternalImpliesDYStar(corruptIds, l2, l3)
    ctx.canFlowInternalResolveMeetRhs_DYStar(corruptIds, l1, l2, l3)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l3)
}

ghost
decreases label.GetHeight(l1)
requires ctx.canFlowInternal_DYStar(corruptIds, l1, label.Meet(l2, l3))
requires ctx.canFlowInternal_DYStar(corruptIds, l2, l3)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, l3)
func (ctx LabelingContext) canFlowInternalResolveMeetRhs_DYStar(corruptIds set[p.Id], l1, l2, l3 label.SecrecyLabel) {
    if ctx.canFlowInternal_DYStar(corruptIds, l1, l2) {
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l1, l2, l3)
    }
    if l1.IsMeet() {
        if !ctx.canFlowInternal_DYStar(corruptIds, l1, l3) {
            ctx.canFlowInternalResolveMeetRhs_DYStar(corruptIds, label.GetFirstLabel(l1), l2, l3)
            ctx.canFlowInternalResolveMeetRhs_DYStar(corruptIds, label.GetSecondLabel(l1), l2, l3)
        }
    } else if l1.IsJoin() {
        if ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), label.Meet(l2, l3)) {
            ctx.canFlowInternalResolveMeetRhs_DYStar(corruptIds, label.GetFirstLabel(l1), l2, l3)
        } else if ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), label.Meet(l2, l3)) {
            ctx.canFlowInternalResolveMeetRhs_DYStar(corruptIds, label.GetSecondLabel(l1), l2, l3)
        }
    }
}

ghost
decreases
requires ctx.CanFlow(t, l1, l3) || ctx.CanFlow(t, l2, l3)
ensures  ctx.CanFlow(t, label.Join(l1, l2), l3)
func (ctx LabelingContext) CanFlowCreateJoinLhs(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalCreateJoinLhs(t.getCorruptIds(), l1, l2, l3)
}

ghost
decreases
requires ctx.canFlowInternal(corruptIds, l1, l3) || ctx.canFlowInternal(corruptIds, l2, l3)
ensures  ctx.canFlowInternal(corruptIds, label.Join(l1, l2), l3)
func (ctx LabelingContext) canFlowInternalCreateJoinLhs(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel) {
    if ctx.canFlowInternal(corruptIds, l1, l3) {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l3)
    } else {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l2, l3)
    }
    ctx.canFlowInternalCreateJoinLhs_DYStar(corruptIds, l1, l2, l3)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, label.Join(l1, l2), l3)
}

ghost
decreases
requires ctx.canFlowInternal_DYStar(corruptIds, l1, l3) || ctx.canFlowInternal_DYStar(corruptIds, l2, l3)
ensures  ctx.canFlowInternal_DYStar(corruptIds, label.Join(l1, l2), l3)
func (ctx LabelingContext) canFlowInternalCreateJoinLhs_DYStar(corruptIds set[p.Id], l1, l2, l3 label.SecrecyLabel) {
    // no body needed
}

ghost
decreases label.GetHeight(l2)
requires ctx.canFlowInternal_DYStar(corruptIds, label.Join(l1, l1), l2)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
// note that it does not hold that ctx.canFlowInternal_DYStar(corruptIds, label.Join(l1, l2), l3) ==>
//    (ctx.canFlowInternal_DYStar(corruptIds, l1, l3) ||
//     ctx.canFlowInternal_DYStar(corruptIds, l2, l3))
// the lhs is weaker because it permits that l1 flows to l31 and l2 to l32 (if l3 == Meet(l31, l32))
func (ctx LabelingContext) canFlowInternalResolveJoinLhs_DYStar(corruptIds set[p.Id], l1, l2 label.SecrecyLabel) {
    if (l2.IsMeet()) {
        if (ctx.canFlowInternal_DYStar(corruptIds, label.Join(l1, l1), label.GetFirstLabel(l2))) {
            ctx.canFlowInternalResolveJoinLhs_DYStar(corruptIds, l1, label.GetFirstLabel(l2))
        } else if (ctx.canFlowInternal_DYStar(corruptIds, label.Join(l1, l1), label.GetSecondLabel(l2))) {
            ctx.canFlowInternalResolveJoinLhs_DYStar(corruptIds, l1, label.GetSecondLabel(l2))
        }
    } else if (l2.IsJoin()) {
        if (!ctx.canFlowInternal_DYStar(corruptIds, l1, l2)) {
            ctx.canFlowInternalResolveJoinLhs_DYStar(corruptIds, l1, label.GetFirstLabel(l2))
            ctx.canFlowInternalResolveJoinLhs_DYStar(corruptIds, l1, label.GetSecondLabel(l2))
        }
    }
}

ghost
decreases
requires ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
requires ctx.canFlowInternal_DYStar(corruptIds, l1, l3)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, label.Join(l2, l3))
func (ctx LabelingContext) canFlowInternalCreateJoinRhs_DYStar(corruptIds set[p.Id], l1, l2, l3 label.SecrecyLabel) {
    // no body needed
}

ghost
decreases
requires ctx.CanFlow(t, l1, label.Join(l2, l3))
ensures  ctx.CanFlow(t, l1, l2)
ensures  ctx.CanFlow(t, l1, l3)
func (ctx LabelingContext) CanFlowResolveJoinRhs(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalResolveJoinRhs(t.getCorruptIds(), l1, l2, l3)
}

ghost
decreases
requires ctx.canFlowInternal(corruptIds, l1, label.Join(l2, l3))
ensures  ctx.canFlowInternal(corruptIds, l1, l2)
ensures  ctx.canFlowInternal(corruptIds, l1, l3)
func (ctx LabelingContext) canFlowInternalResolveJoinRhs(corruptIds set[p.Id], l1, l2, l3 label.SecrecyLabel) {
    ctx.canFlowInternalImpliesDYStar(corruptIds, l1, label.Join(l2, l3))
    ctx.canFlowInternalResolveJoinRhs_DYStar(corruptIds, l1, l2, l3)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l2)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l3)
}

ghost
decreases label.GetHeight(l1)
requires ctx.canFlowInternal_DYStar(corruptIds, l1, label.Join(l2, l3))
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, l3)
func (ctx LabelingContext) canFlowInternalResolveJoinRhs_DYStar(corruptIds set[p.Id], l1, l2, l3 label.SecrecyLabel) {
    if (l1.IsMeet() || l1.IsJoin()) {
        if (ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), label.Join(l2, l3))) {
            ctx.canFlowInternalResolveJoinRhs_DYStar(corruptIds, label.GetFirstLabel(l1), l2, l3)
        }
        if (ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), label.Join(l2, l3))) {
            ctx.canFlowInternalResolveJoinRhs_DYStar(corruptIds, label.GetSecondLabel(l1), l2, l3)
        }
    }
}

ghost
decreases
requires ctx.CanFlow(t, l1, label.Meet(l2, l3))
requires  l2FlowsToPublic ==> ctx.CanFlow(t, l2, label.Public())
requires !l2FlowsToPublic ==> ctx.CanFlow(t, l3, label.Public())
ensures   l2FlowsToPublic ==> ctx.CanFlow(t, l1, l3)
ensures  !l2FlowsToPublic ==> ctx.CanFlow(t, l1, l2)
func (ctx LabelingContext) CanFlowResolveMeetPublicRhs(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel, l2FlowsToPublic bool) {
    ctx.canFlowInternalResolveMeetPublicRhs(t.getCorruptIds(), l1, l2, l3, l2FlowsToPublic)
}

ghost
decreases
requires ctx.canFlowInternal(corruptIds, l1, label.Meet(l2, l3))
requires  l2FlowsToPublic ==> ctx.canFlowInternal(corruptIds, l2, label.Public())
requires !l2FlowsToPublic ==> ctx.canFlowInternal(corruptIds, l3, label.Public())
ensures   l2FlowsToPublic ==> ctx.canFlowInternal(corruptIds, l1, l3)
ensures  !l2FlowsToPublic ==> ctx.canFlowInternal(corruptIds, l1, l2)
func (ctx LabelingContext) canFlowInternalResolveMeetPublicRhs(corruptIds set[p.Id], l1, l2, l3 label.SecrecyLabel, l2FlowsToPublic bool) {
    ctx.canFlowInternalImpliesDYStar(corruptIds, l1, label.Meet(l2, l3))
    if l2FlowsToPublic {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l2, label.Public())
    } else {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l3, label.Public())
    }
    ctx.canFlowInternalResolveMeetPublicRhs_DYStar(corruptIds, l1, l2, l3, l2FlowsToPublic)
    if l2FlowsToPublic {
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l3)
    } else {
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l2)
    }
}

ghost
decreases label.GetHeight(l1)
requires ctx.canFlowInternal_DYStar(corruptIds, l1, label.Meet(l2, l3))
requires  l2FlowsToPublic ==> ctx.canFlowInternal_DYStar(corruptIds, l2, label.Public())
requires !l2FlowsToPublic ==> ctx.canFlowInternal_DYStar(corruptIds, l3, label.Public())
ensures   l2FlowsToPublic ==> ctx.canFlowInternal_DYStar(corruptIds, l1, l3)
ensures  !l2FlowsToPublic ==> ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
func (ctx LabelingContext) canFlowInternalResolveMeetPublicRhs_DYStar(corruptIds set[p.Id], l1, l2, l3 label.SecrecyLabel, l2FlowsToPublic bool) {
    if (ctx.canFlowInternal_DYStar(corruptIds, l1, label.Public())) {
        ctx.flowsToPublicCanFlowInternal_DYStar(corruptIds, l1, l2)
        ctx.flowsToPublicCanFlowInternal_DYStar(corruptIds, l1, l3)
    }
    if ctx.canFlowInternal_DYStar(corruptIds, l1, l2) {
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l1, l2, label.Public())
    }
    if ctx.canFlowInternal_DYStar(corruptIds, l1, l3) {
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l1, l3, label.Public())
    }

    if (l1.IsMeet()) {
        if (!ctx.canFlowInternal_DYStar(corruptIds, l1, l2) && !ctx.canFlowInternal_DYStar(corruptIds, l1, l3)) {
            ctx.canFlowInternalResolveMeetPublicRhs_DYStar(corruptIds, label.GetFirstLabel(l1), l2, l3, l2FlowsToPublic)
            ctx.canFlowInternalResolveMeetPublicRhs_DYStar(corruptIds, label.GetSecondLabel(l1), l2, l3, l2FlowsToPublic)
        }
    } else if (l1.IsJoin()) {
        if (ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), label.Meet(l2, l3))) {
            ctx.canFlowInternalResolveMeetPublicRhs_DYStar(corruptIds, label.GetFirstLabel(l1), l2, l3, l2FlowsToPublic)
        } else if (ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), label.Meet(l2, l3))) {
            ctx.canFlowInternalResolveMeetPublicRhs_DYStar(corruptIds, label.GetSecondLabel(l1), l2, l3, l2FlowsToPublic)
        }
    }
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) IsPublishable(t tr.TraceEntry, term tm.Term) bool {
    return ctx.IsMsg(t, term, label.Public())
}

ghost
decreases
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsPublishable(t1, term)
ensures  ctx.IsPublishable(t2, term)
func (ctx LabelingContext) IsPublishableMonotonic(t1, t2 tr.TraceEntry, term tm.Term) {
    ctx.IsMsgMonotonic(t1, t2, term, label.Public())
}

ghost
decreases
pure func (ctx LabelingContext) CanFlow(t tr.TraceEntry, l1, l2 label.SecrecyLabel) bool {
    return ctx.canFlowInternal(t.getCorruptIds(), l1, l2)
}

ghost
decreases label.GetHeight(l1), label.GetHeight(l2)
/** this is the canFlowInternal function that we use throughout */
pure func (ctx LabelingContext) canFlowInternal(corruptIds set[p.Id], l1, l2 label.SecrecyLabel) bool {
    // public can flow to anything
    return l1.IsPublic() ? true :
        ////////// begin special cases //////////
        // begin special case 1: meet or join of two identical labels is identical to one of them (l1 case)
        ((l1.IsMeet() || l1.IsJoin()) && label.GetFirstLabel(l1) == label.GetSecondLabel(l1)) ? ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) :
        // end special case 1
        // begin special case 2: meet or join of two identical labels is identical to one of them (l2 case)
        ((l2.IsMeet() || l2.IsJoin()) && label.GetFirstLabel(l2) == label.GetSecondLabel(l2)) ? ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) :
        // end special case 2
        // begin special case 3: meet of two labels, one of which being public (l1 case)
        (l1.IsMeet() && label.GetFirstLabel(l1).IsPublic()) ? ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2) :
        (l1.IsMeet() && label.GetSecondLabel(l1).IsPublic()) ? ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) :
        // end special case 3
        // begin special case 4: meet of two labels, one of which being public (l2 case)
        (l2.IsMeet() && label.GetFirstLabel(l2).IsPublic()) ? ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2)) :
        (l2.IsMeet() && label.GetSecondLabel(l2).IsPublic()) ? ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) :
        // end special case 4
        ////////// end special cases //////////
        // label with a corrupted reader flows to public
        (l1.IsReaders() && l2.IsPublic()) ? tr.containsCorruptId(corruptIds, label.GetReaders(l1)) :
        // l1 is superset of l2 or some ID in l1 is corrupt
        (l1.IsReaders() && l2.IsReaders()) ? (includesIds(label.GetReaders(l1), label.GetReaders(l2)) || tr.containsCorruptId(corruptIds, label.GetReaders(l1))) :
        // l1 flows to l2 == meet(l21, l22) if l1 flows to l21 OR l22 because meet(l21, l22) is stricter than l21 or l22
        (l1.IsReaders() && l2.IsMeet()) ? (ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) || ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) :
        // l1 flows to l2 == join(l21, l22) if l1 flows to l21 AND l22
        (l1.IsReaders() && l2.IsJoin()) ? (ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) && ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) :
        (l1.IsJoin() && (l2.IsPublic() || l2.IsReaders())) ? (ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) || ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2)) :
        (l1.IsMeet() && (l2.IsPublic() || l2.IsReaders())) ? (ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) && ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2)) :
        (l1.IsJoin() && l2.IsMeet()) ? ((ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) || ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) || ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2))) :
        (l1.IsMeet() && l2.IsMeet()) ? ((ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) || ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) && ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2))) :
        (l1.IsMeet() && l2.IsJoin()) ? ((ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) && ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) && ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2))) :
        (l1.IsJoin() && l2.IsJoin()) ? ((ctx.canFlowInternal(corruptIds, l1, label.GetFirstLabel(l2)) && ctx.canFlowInternal(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal(corruptIds, label.GetFirstLabel(l1), l2) || ctx.canFlowInternal(corruptIds, label.GetSecondLabel(l1), l2))) :
            false
        // rule of thumb:
        // l1 being a join or l2 being a meet results in disjunctions
        // l1 being a meet or l2 being a join results in conjunctions
}

ghost
/** 
  * this is the orginal `can_flow` function used by DY*.
  * we show below that `canFlowInternal` and `canFlowInternal_DYStar` are equivalent.
  */
pure func (ctx LabelingContext) canFlowInternal_DYStar(corruptIds IdSet, l1, l2 label.SecrecyLabel) bool {
    // public can flow to anything
    return (l1.IsPublic() ==> true) &&
        // label with a corrupted reader flows to public
        (l1.IsReaders() && l2.IsPublic() ==> tr.containsCorruptId(corruptIds, label.GetReaders(l1))) &&
        // l1 is superset of l2 or some ID in l1 is corrupt
        (l1.IsReaders() && l2.IsReaders() ==> (includesIds(label.GetReaders(l1), label.GetReaders(l2)) || tr.containsCorruptId(corruptIds, label.GetReaders(l1)))) &&
        // l1 flows to l2 == meet(l21, l22) if l1 flows to l21 OR l22 because meet(l21, l22) is stricter than l21 or l22
        (l1.IsReaders() && l2.IsMeet() ==> ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetFirstLabel(l2)) || ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetSecondLabel(l2))) &&
        // l1 flows to l2 == join(l21, l22) if l1 flows to l21 AND l22
        (l1.IsReaders() && l2.IsJoin() ==> ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetFirstLabel(l2)) && ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetSecondLabel(l2))) &&
        (l1.IsJoin() && (l2.IsPublic() || l2.IsReaders()) ==> ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), l2) || ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), l2)) &&
        (l1.IsMeet() && (l2.IsPublic() || l2.IsReaders()) ==> ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), l2) && ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), l2)) &&
        (l1.IsJoin() && l2.IsMeet() ==> (ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetFirstLabel(l2)) || ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), l2) || ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), l2))) &&
        (l1.IsMeet() && l2.IsMeet() ==> (ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetFirstLabel(l2)) || ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), l2) && ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), l2))) &&
        (l1.IsMeet() && l2.IsJoin() ==> (ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetFirstLabel(l2)) && ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), l2) && ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), l2))) &&
        (l1.IsJoin() && l2.IsJoin() ==> (ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetFirstLabel(l2)) && ctx.canFlowInternal_DYStar(corruptIds, l1, label.GetSecondLabel(l2))) || (ctx.canFlowInternal_DYStar(corruptIds, label.GetFirstLabel(l1), l2) || ctx.canFlowInternal_DYStar(corruptIds, label.GetSecondLabel(l1), l2)))
        // rule of thumb:
        // l1 being a join or l2 being a meet results in disjunctions
        // l1 being a meet or l2 being a join results in conjunctions
}

ghost
decreases label.GetHeight(l1), label.GetHeight(l2)
requires ctx.canFlowInternal(corruptIds, l1, l2)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
func (ctx LabelingContext) canFlowInternalImpliesDYStar(corruptIds set[p.Id], l1, l2 label.SecrecyLabel) {
    if (l1.IsMeet() || l1.IsJoin()) && label.GetFirstLabel(l1) == label.GetSecondLabel(l1) {
        // special case 1
        l11 := label.GetFirstLabel(l1)
        ctx.canFlowInternalImpliesDYStar(corruptIds, l11, l2)
        if l1.IsMeet() {
            ctx.canFlowInternalCreateMeetLhs_DYStar(corruptIds, l11, l11, l2)
        } else {
            ctx.canFlowInternalCreateJoinLhs_DYStar(corruptIds, l11, l11, l2)
        }
    } else if (l2.IsMeet() || l2.IsJoin()) && label.GetFirstLabel(l2) == label.GetSecondLabel(l2) {
        // special case 2
        l21 := label.GetFirstLabel(l2)
        ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l21)
        if l1.IsMeet() {
            ctx.canFlowInternalCreateMeetRhs_DYStar(corruptIds, l1, l21, l21)
        } else {
            ctx.canFlowInternalCreateJoinRhs_DYStar(corruptIds, l1, l21, l21)
        }
    } else if l1.IsMeet() && (label.GetFirstLabel(l1).IsPublic() || label.GetSecondLabel(l1).IsPublic()) {
        // special case 3
        l11 := label.GetFirstLabel(l1)
        l12 := label.GetSecondLabel(l1)
        ctx.canFlowInternalImpliesDYStar(corruptIds, l11, l2)
        ctx.canFlowInternalImpliesDYStar(corruptIds, l12, l2)
        ctx.canFlowInternalCreateMeetLhs_DYStar(corruptIds, l11, l12, l2)
    } else if l2.IsMeet() && (label.GetFirstLabel(l2).IsPublic() || label.GetSecondLabel(l2).IsPublic()) {
        // special case 4
        l21 := label.GetFirstLabel(l2)
        l22 := label.GetSecondLabel(l2)
        if ctx.canFlowInternal(corruptIds, l1, l21) {
            ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l21)
        }
        if ctx.canFlowInternal(corruptIds, l1, l22) {
            ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l22)
        }
        ctx.canFlowInternalCreateMeetRhs_DYStar(corruptIds, l1, l21, l22)
    } else {
        if l1.IsMeet() || l1.IsJoin() {
            l11 := label.GetFirstLabel(l1)
            l12 := label.GetSecondLabel(l1)
            if ctx.canFlowInternal(corruptIds, l11, l2) {
                ctx.canFlowInternalImpliesDYStar(corruptIds, l11, l2)
            }
            if ctx.canFlowInternal(corruptIds, l12, l2) {
                ctx.canFlowInternalImpliesDYStar(corruptIds, l12, l2)
            }
        }
        if l2.IsMeet() || l2.IsJoin() {
            l21 := label.GetFirstLabel(l2)
            l22 := label.GetSecondLabel(l2)
            if ctx.canFlowInternal(corruptIds, l1, l21) {
                ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l21)
            }
            if ctx.canFlowInternal(corruptIds, l1, l22) {
                ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l22)
            }
        }
    }
}

ghost
decreases label.GetHeight(l1), label.GetHeight(l2)
requires ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
ensures  ctx.canFlowInternal(corruptIds, l1, l2)
func (ctx LabelingContext) canFlowInternalIsImpliesByDYStar(corruptIds set[p.Id], l1, l2 label.SecrecyLabel) {
    if (l1.IsMeet() || l1.IsJoin()) && label.GetFirstLabel(l1) == label.GetSecondLabel(l1) {
        // special case 1
        l11 := label.GetFirstLabel(l1)
        if l1.IsMeet() {
            ctx.canFlowInternalResolveMeetLhs_DYStar(corruptIds, l11, l11, l2)
        } else {
            ctx.canFlowInternalResolveJoinLhs_DYStar(corruptIds, l11, l2)
        }
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l11, l2)
    } else if (l2.IsMeet() || l2.IsJoin()) && label.GetFirstLabel(l2) == label.GetSecondLabel(l2) {
        // special case 2
        l21 := label.GetFirstLabel(l2)
        if l2.IsMeet() {
            ctx.canFlowInternalReflexive_DYStar(corruptIds, l21)
            ctx.canFlowInternalResolveMeetRhs_DYStar(corruptIds, l1, l21, l21)
        } else {
            ctx.canFlowInternalResolveJoinRhs_DYStar(corruptIds, l1, l21, l21)
        }
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l21)
    } else if l1.IsMeet() && (label.GetFirstLabel(l1).IsPublic() || label.GetSecondLabel(l1).IsPublic()) {
        // special case 3
        l11 := label.GetFirstLabel(l1)
        l12 := label.GetSecondLabel(l1)
        ctx.canFlowInternalResolveMeetLhs_DYStar(corruptIds, l11, l12, l2)
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l12, l2)
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l11, l2)
    } else if l2.IsMeet() && (label.GetFirstLabel(l2).IsPublic() || label.GetSecondLabel(l2).IsPublic()) {
        // special case 4
        l21 := label.GetFirstLabel(l2)
        l22 := label.GetSecondLabel(l2)
        ctx.canFlowInternalResolveMeetPublicRhs_DYStar(corruptIds, l1, l21, l22, l21.IsPublic())
        if l21.IsPublic() {
            ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l22)
        } else {
            ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l21)
        }
    } else {
        if l1.IsMeet() || l1.IsJoin() {
            l11 := label.GetFirstLabel(l1)
            l12 := label.GetSecondLabel(l1)
            if ctx.canFlowInternal_DYStar(corruptIds, l11, l2) {
                ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l11, l2)
            }
            if ctx.canFlowInternal_DYStar(corruptIds, l12, l2) {
                ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l12, l2)
            }
        }
        if l2.IsMeet() || l2.IsJoin() {
            l21 := label.GetFirstLabel(l2)
            l22 := label.GetSecondLabel(l2)
            if ctx.canFlowInternal_DYStar(corruptIds, l1, l21) {
                ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l21)
            }
            if ctx.canFlowInternal_DYStar(corruptIds, l1, l22) {
                ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l22)
            }
        }
    }
}

ghost
decreases
ensures  ctx.CanFlow(t, l, l)
func (ctx LabelingContext) CanFlowReflexive(t tr.TraceEntry, l label.SecrecyLabel) {
    corruptIds := t.getCorruptIds()
    ctx.canFlowInternalReflexive(corruptIds, l)
}

ghost
decreases
ensures  ctx.canFlowInternal(corruptIds, l, l)
func (ctx LabelingContext) canFlowInternalReflexive(corruptIds IdSet, l label.SecrecyLabel) {
    ctx.canFlowInternalReflexive_DYStar(corruptIds, l)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l, l)
}

ghost
decreases label.GetHeight(l)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l, l)
func (ctx LabelingContext) canFlowInternalReflexive_DYStar(corruptIds IdSet, l label.SecrecyLabel) {
    if l.IsReaders() {
        ctx.includesIdsReflexive(label.GetReaders(l))
    } else if (l.IsJoin()) {
        l1 := label.GetFirstLabel(l)
        l2 := label.GetSecondLabel(l)
        ctx.canFlowInternalReflexive_DYStar(corruptIds, l1)
        ctx.canFlowInternalReflexive_DYStar(corruptIds, l2)
        // the following assert stmts are needed
        assert ctx.canFlowInternal_DYStar(corruptIds, l, l1)
        assert ctx.canFlowInternal_DYStar(corruptIds, l, l2)
    } else if (l.IsMeet()) {
        l1 := label.GetFirstLabel(l)
        l2 := label.GetSecondLabel(l)
        ctx.canFlowInternalReflexive_DYStar(corruptIds, l1)
        ctx.canFlowInternalReflexive_DYStar(corruptIds, l2)
        // the following assert stmts are needed
        assert ctx.canFlowInternal_DYStar(corruptIds, l1, l)
        assert ctx.canFlowInternal_DYStar(corruptIds, l2, l)
    }
}

ghost
decreases
requires ctx.CanFlow(t, l1, l2)
requires ctx.CanFlow(t, l2, l3)
ensures  ctx.CanFlow(t, l1, l3)
func (ctx LabelingContext) CanFlowTransitive(t tr.TraceEntry, l1, l2, l3 label.SecrecyLabel) {
    corruptIds := t.getCorruptIds()
    ctx.canFlowInternalTransitive(corruptIds, l1, l2, l3)
}

ghost
decreases
ensures (ctx.canFlowInternal(corruptIds, l1, l2) && ctx.canFlowInternal(corruptIds, l2, l3)) ==> ctx.canFlowInternal(corruptIds, l1, l3)
func (ctx LabelingContext) canFlowInternalTransitive(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel) {
    if ctx.canFlowInternal(corruptIds, l1, l2) && ctx.canFlowInternal(corruptIds, l2, l3) {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l2)
        ctx.canFlowInternalImpliesDYStar(corruptIds, l2, l3)
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l1, l2, l3)
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l3)
    }
}

ghost
decreases label.GetHeight(l1), label.GetHeight(l2), label.GetHeight(l3)
ensures (ctx.canFlowInternal_DYStar(corruptIds, l1, l2) && ctx.canFlowInternal_DYStar(corruptIds, l2, l3)) ==> ctx.canFlowInternal_DYStar(corruptIds, l1, l3)
func (ctx LabelingContext) canFlowInternalTransitive_DYStar(corruptIds IdSet, l1, l2, l3 label.SecrecyLabel) {
    if (l1.IsPublic()) {
        // no body needed
        return
    }
    if (l2.IsPublic()) {
        ctx.flowsToPublicCanFlowInternal_DYStar(corruptIds, l1, l3)
        return
    }
    if (l3.IsPublic()) {
        ctx.canFlowFlowsToPublic_DYStar(corruptIds, l1, l2)
        return
    }

    if l1.IsReaders() && l2.IsReaders() && l3.IsReaders() &&
        includesIds(label.GetReaders(l1), label.GetReaders(l2)) &&
        includesIds(label.GetReaders(l2), label.GetReaders(l3)) {
        ctx.includesIdsTransitive(label.GetReaders(l1), label.GetReaders(l2), label.GetReaders(l3))
    }

    if l1.IsReaders() && l2.IsReaders() && l3.IsReaders() &&
        ctx.canFlowInternal_DYStar(corruptIds, l1, l2) &&
        ctx.canFlowInternal_DYStar(corruptIds, l2, l3) &&
        includesIds(label.GetReaders(l1), label.GetReaders(l2)) &&
        tr.containsCorruptId(corruptIds, label.GetReaders(l2)) {
        ctx.containsCorruptIdMonotonic(corruptIds, label.GetReaders(l2), label.GetReaders(l1))
    }

    if (l1.IsJoin() || l1.IsMeet()) {
        l11 := label.GetFirstLabel(l1)
        l12 := label.GetSecondLabel(l1)
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l11, l2, l3)
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l12, l2, l3)
    }
    if (l2.IsJoin() || l2.IsMeet()) {
        l21 := label.GetFirstLabel(l2)
        l22 := label.GetSecondLabel(l2)
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l1, l21, l3)
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l1, l22, l3)
    }
    if (l3.IsJoin() || l3.IsMeet()) {
        l31 := label.GetFirstLabel(l3)
        l32 := label.GetSecondLabel(l3)
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l1, l2, l31)
        ctx.canFlowInternalTransitive_DYStar(corruptIds, l1, l2, l32)
    }
}

ghost
decreases
ensures  ctx.CanFlow(t, l1, label.Public()) ==> ctx.CanFlow(t, l1, l2)
func (ctx LabelingContext) FlowsToPublicCanFlow(t tr.TraceEntry, l1, l2 label.SecrecyLabel) {
    ctx.flowsToPublicCanFlowInternal(t.getCorruptIds(), l1, l2)
}

ghost
decreases
ensures  ctx.canFlowInternal(corruptIds, l1, label.Public()) ==> ctx.canFlowInternal(corruptIds, l1, l2)
func (ctx LabelingContext) flowsToPublicCanFlowInternal(corruptIds IdSet, l1, l2 label.SecrecyLabel) {
    if ctx.canFlowInternal(corruptIds, l1, label.Public()) {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l1, label.Public())
        ctx.flowsToPublicCanFlowInternal_DYStar(corruptIds, l1, l2)
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l2)
    }
}

ghost
decreases label.GetHeight(l1), label.GetHeight(l2)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, label.Public()) ==> ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
func (ctx LabelingContext) flowsToPublicCanFlowInternal_DYStar(corruptIds IdSet, l1, l2 label.SecrecyLabel) {
    if (l1.IsJoin() || l1.IsMeet()) {
        l11 := label.GetFirstLabel(l1)
        l12 := label.GetSecondLabel(l1)
        ctx.flowsToPublicCanFlowInternal_DYStar(corruptIds, l11, l2)
        ctx.flowsToPublicCanFlowInternal_DYStar(corruptIds, l12, l2)
    }
    if (l2.IsJoin() || l2.IsMeet()) {
        l21 := label.GetFirstLabel(l2)
        l22 := label.GetSecondLabel(l2)
        ctx.flowsToPublicCanFlowInternal_DYStar(corruptIds, l1, l21)
        ctx.flowsToPublicCanFlowInternal_DYStar(corruptIds, l1, l22)
    }
}

ghost
decreases
ensures  (ctx.canFlowInternal(corruptIds, l2, label.Public()) && ctx.canFlowInternal(corruptIds, l1, l2)) ==> ctx.canFlowInternal(corruptIds, l1, label.Public())
func (ctx LabelingContext) canFlowFlowsToPublic(corruptIds IdSet, l1, l2 label.SecrecyLabel) {
    if ctx.canFlowInternal(corruptIds, l2, label.Public()) && ctx.canFlowInternal(corruptIds, l1, l2) {
        ctx.canFlowInternalImpliesDYStar(corruptIds, l2, label.Public())
        ctx.canFlowInternalImpliesDYStar(corruptIds, l1, l2)
        ctx.canFlowFlowsToPublic_DYStar(corruptIds, l1, l2)
        ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, label.Public())
    }
}

ghost
decreases label.GetHeight(l1), label.GetHeight(l2)
ensures  (ctx.canFlowInternal_DYStar(corruptIds, l2, label.Public()) && ctx.canFlowInternal_DYStar(corruptIds, l1, l2)) ==> ctx.canFlowInternal_DYStar(corruptIds, l1, label.Public())
func (ctx LabelingContext) canFlowFlowsToPublic_DYStar(corruptIds IdSet, l1, l2 label.SecrecyLabel) {
    if l1.IsReaders() && l2.IsReaders() &&
        ctx.canFlowInternal_DYStar(corruptIds, l2, label.Public()) &&
        ctx.canFlowInternal_DYStar(corruptIds, l1, l2) &&
        includesIds(label.GetReaders(l1), label.GetReaders(l2)) {
        ctx.containsCorruptIdMonotonic(corruptIds, label.GetReaders(l2), label.GetReaders(l1))
    }
    if (l1.IsJoin() || l1.IsMeet()) {
        l11 := label.GetFirstLabel(l1)
        l12 := label.GetSecondLabel(l1)
        ctx.canFlowFlowsToPublic_DYStar(corruptIds, l11, l2)
        ctx.canFlowFlowsToPublic_DYStar(corruptIds, l12, l2)
    }
    if (l2.IsJoin() || l2.IsMeet()) {
        l21 := label.GetFirstLabel(l2)
        l22 := label.GetSecondLabel(l2)
        ctx.canFlowFlowsToPublic_DYStar(corruptIds, l1, l21)
        ctx.canFlowFlowsToPublic_DYStar(corruptIds, l1, l22)
    }
}

ghost
decreases
requires l1.IsReaders() && l2.IsReaders()
requires label.GetReaders(l2) subset label.GetReaders(l1)
ensures  ctx.CanFlow(t, l1, l2)
func (ctx LabelingContext) CanFlowToSubsetReaders(t tr.TraceEntry, l1, l2 label.SecrecyLabel) {
    corruptIds := t.getCorruptIds()
    ctx.canFlowInternalToSubsetReaders(corruptIds, l1, l2)
}

ghost
decreases
requires l1.IsReaders() && l2.IsReaders()
requires label.GetReaders(l2) subset label.GetReaders(l1)
ensures  ctx.canFlowInternal(corruptIds, l1, l2)
func (ctx LabelingContext) canFlowInternalToSubsetReaders(corruptIds IdSet, l1, l2 label.SecrecyLabel) {
    ctx.canFlowInternalToSubsetReaders_DYStar(corruptIds, l1, l2)
    ctx.canFlowInternalIsImpliesByDYStar(corruptIds, l1, l2)
}

ghost
decreases
requires l1.IsReaders() && l2.IsReaders()
requires label.GetReaders(l2) subset label.GetReaders(l1)
ensures  ctx.canFlowInternal_DYStar(corruptIds, l1, l2)
func (ctx LabelingContext) canFlowInternalToSubsetReaders_DYStar(corruptIds IdSet, l1, l2 label.SecrecyLabel) {
    ids1 := label.GetReaders(l1)
    ids2 := label.GetReaders(l2)
    ctx.includesIdsSubset(ids1, ids2)
}

ghost
decreases
requires t1.isSuffix(t2)
requires ctx.CanFlow(t1, l1, l2)
ensures  ctx.CanFlow(t2, l1, l2)
func (ctx LabelingContext) CanFlowMonotonic(t1, t2 tr.TraceEntry, l1, l2 label.SecrecyLabel) {
    ctx.CanFlowMonotonicInternal(t1, t2, l1, l2)
}

ghost
decreases label.GetHeight(l1), label.GetHeight(l2)
requires t1.isSuffix(t2)
ensures  ctx.CanFlow(t1, l1, l2) ==> ctx.CanFlow(t2, l1, l2)
func (ctx LabelingContext) CanFlowMonotonicInternal(t1, t2 tr.TraceEntry, l1, l2 label.SecrecyLabel) {
    if (!l1.IsJoin() && !l1.IsMeet() && !l2.IsJoin() && !l2.IsMeet()) {
        t1.getCorruptIdsMonotonic(t2)
    } else {
        if (l1.IsJoin() || l1.IsMeet()) {
            l11 := label.GetFirstLabel(l1)
            l12 := label.GetSecondLabel(l1)
            ctx.CanFlowMonotonicInternal(t1, t2, l11, l2)
            ctx.CanFlowMonotonicInternal(t1, t2, l12, l2)
        }
        if (l2.IsJoin() || l2.IsMeet()) {
            l21 := label.GetFirstLabel(l2)
            l22 := label.GetSecondLabel(l2)
            ctx.CanFlowMonotonicInternal(t1, t2, l1, l21)
            ctx.CanFlowMonotonicInternal(t1, t2, l1, l22)
        }
    }
}

ghost
decreases
requires ctx.CanFlow(t, label.Readers(set[p.Id]{ id }), label.Public())
ensures  corruptedId in t.getCorruptIds() && id.Covers(corruptedId)
func (ctx LabelingContext) CanFlowToPublicImpliesCorruption(t tr.TraceEntry, id p.Id) (corruptedId p.Id) {
    assert exists corruptedId p.Id :: corruptedId in t.getCorruptIds() && id.Covers(corruptedId)
    // get witness
    corruptedId := arb.GetArbId()
    assume corruptedId in t.getCorruptIds() && id.Covers(corruptedId)
}

ghost
decreases
requires ids1 subset ids2 || includesIds(ids2, ids1)
requires tr.containsCorruptId(corruptIds, ids1)
ensures  tr.containsCorruptId(corruptIds, ids2)
func (ctx LabelingContext) containsCorruptIdMonotonic(corruptIds, ids1, ids2 set[p.Id]) {
    assert exists corruptedId p.Id :: { tr.containsId(ids1, corruptedId) } corruptedId in corruptIds && tr.containsId(ids1, corruptedId)
    // get witness:
    corruptedId := arb.GetArbId()
    assume corruptedId in corruptIds && tr.containsId(ids1, corruptedId)
    if includesIds(ids2, ids1) {
        ctx.containsIdTransitive(ids1, ids2, corruptedId)
    }
    // the following assert stmt is necessary:
    assert tr.containsId(ids2, corruptedId)
}

ghost
decreases
requires corruptIds1 subset corruptIds2
requires tr.containsCorruptId(corruptIds1, ids)
ensures  tr.containsCorruptId(corruptIds2, ids)
func (ctx LabelingContext) containsCorruptIdMonotonic2(corruptIds1, corruptIds2, ids set[p.Id]) {
    assert exists corruptedId p.Id :: { tr.containsId(ids, corruptedId) } corruptedId in corruptIds1 && tr.containsId(ids, corruptedId)
    // get witness:
    corruptedId := arb.GetArbId()
    assume corruptedId in corruptIds1 && tr.containsId(ids, corruptedId)
    assert corruptedId in corruptIds2
}

ghost
decreases
requires tr.containsCorruptId(corruptIds, ids1 union ids2)
ensures  tr.containsCorruptId(corruptIds, ids1) || tr.containsCorruptId(corruptIds, ids2)
func (ctx LabelingContext) containsCorruptIdSplit(corruptIds set[p.Id], ids1, ids2 set[p.Id]) {
    ids := ids1 union ids2
    assert exists corruptedId p.Id :: { tr.containsId(ids, corruptedId) } corruptedId in corruptIds && tr.containsId(ids, corruptedId)
    // get witness:
    corruptedId := arb.GetArbId()
    assume corruptedId in corruptIds && tr.containsId(ids, corruptedId)
    ctx.containsIdSplit(ids1, ids2, corruptedId)
}

ghost
decreases
requires tr.containsCorruptId(corruptIds, ids1) || tr.containsCorruptId(corruptIds, ids2)
ensures  tr.containsCorruptId(corruptIds, ids1 union ids2)
func (ctx LabelingContext) containsCorruptIdUnion(corruptIds set[p.Id], ids1, ids2 set[p.Id]) {
    ids := ids1 union ids2
    if tr.containsCorruptId(corruptIds, ids1) {
        ctx.containsCorruptIdMonotonic(corruptIds, ids1, ids)
    } else if tr.containsCorruptId(corruptIds, ids2) {
        ctx.containsCorruptIdMonotonic(corruptIds, ids2, ids)
    }
}

ghost
decreases
ensures  (!tr.containsCorruptId(corruptIds, ids1) && !tr.containsCorruptId(corruptIds, ids2)) == !tr.containsCorruptId(corruptIds, ids1 union ids2)
func (ctx LabelingContext) containsCorruptIdNotUnion(corruptIds set[p.Id], ids1, ids2 set[p.Id]) {
    ids := ids1 union ids2
    if !tr.containsCorruptId(corruptIds, ids1) &&
        !tr.containsCorruptId(corruptIds, ids2) {
        // we prove it by contradiction:
        if tr.containsCorruptId(corruptIds, ids) {
            ctx.containsCorruptIdSplit(corruptIds, ids1, ids2)
        }
    }
    if !tr.containsCorruptId(corruptIds, ids1 union ids2) {
        // we prove it by contradiction:
        if tr.containsCorruptId(corruptIds, ids1) ||
            tr.containsCorruptId(corruptIds, ids2) {
            ctx.containsCorruptIdUnion(corruptIds, ids1, ids2)
        }
    }
}

ghost
decreases
requires tr.containsId(ids1, corruptedId) && includesIds(ids2, ids1)
ensures  tr.containsId(ids2, corruptedId)
func (ctx LabelingContext) containsIdTransitive(ids1, ids2 set[p.Id], corruptedId p.Id) {
    // apply `containsId(ids1, corruptedId)`:
    assert exists id1 p.Id :: { id1.Covers(corruptedId) } id1 in ids1 && id1.Covers(corruptedId)
    // get witness:
    id1 := arb.GetArbId()
    assume id1 in ids1 && id1.Covers(corruptedId)
    
    // apply `includesIds(ids2, ids1)`:
    assert forall id p.Id :: id in ids1 ==> tr.containsId(ids2, id)
    assert tr.containsId(ids2, id1)

    // apply `containsId(ids2, id1)`:
    assert exists id p.Id :: id in ids2 && id.Covers(id1)
    // get witness:
    idX := arb.GetArbId()
    assume idX in ids2 && idX.Covers(id1)

    idX.CoversTransitive(id1, corruptedId)
    assert exists id p.Id :: { id.Covers(corruptedId) } id in ids2 && id.Covers(corruptedId)
}

ghost
decreases
requires tr.containsId(ids1 union ids2, corruptedId)
ensures  tr.containsId(ids1, corruptedId) || tr.containsId(ids2, corruptedId)
func (ctx LabelingContext) containsIdSplit(ids1, ids2 set[p.Id], corruptedId p.Id) {
    // no body needed
}

ghost
decreases
/**
 * checks whether every id in `ids` is contained in `haystack` while taking their
 * coverings into account.
 * This is similar to `containsCorruptId` except that a forall instead of existential
 * quantifier is used for every ID contained in the first parameter.
 */
pure func includesIds(haystack, ids set[p.Id]) bool {
    return forall id p.Id :: { tr.containsId(haystack, id) } id in ids ==> tr.containsId(haystack, id)
}

ghost
decreases
ensures includesIds(ids, ids)
func (ctx LabelingContext) includesIdsReflexive(ids set[p.Id]) {
    arbId := arb.GetArbId()
    if arbId in ids {
        arbId.CoversReflexive()
    }
    // we have shown it for an arbitrary `arbId` and can thus perform forall introduction:
    assert arbId in ids ==> tr.containsId(ids, arbId)
    assume forall id p.Id :: { tr.containsId(ids, id) } id in ids ==> tr.containsId(ids, id)
}

ghost
decreases
requires includesIds(ids1, ids2) && includesIds(ids2, ids3)
ensures  includesIds(ids1, ids3)
func (ctx LabelingContext) includesIdsTransitive(ids1, ids2, ids3 set[p.Id]) {
    assert forall id p.Id :: { tr.containsId(ids1, id) } id in ids2 ==> tr.containsId(ids1, id)
    assert forall id p.Id :: { tr.containsId(ids2, id) } id in ids3 ==> tr.containsId(ids2, id)
    
    arbId := arb.GetArbId()
    if arbId in ids3 {
        // follows from `includesIds(ids2, ids3)`:
        assert tr.containsId(ids2, arbId)
        // use additionally the fact that `includesIds(ids1, ids2)`:
        ctx.containsIdTransitive(ids2, ids1, arbId)
    }
    assert arbId in ids3 ==> tr.containsId(ids1, arbId)
    // we can do a forall introduction as `arbId` is unconstraint:
    assume forall id p.Id :: { tr.containsId(ids1, id) } id in ids3 ==> tr.containsId(ids1, id)
}

ghost
decreases
requires ids2 subset ids1
ensures  includesIds(ids1, ids2)
func (ctx LabelingContext) includesIdsSubset(ids1, ids2 set[p.Id]) {
    arbId := arb.GetArbId()
    if arbId in ids2 {
        // apply `ids2 subset ids1`:
        assert arbId in ids1
        arbId.CoversReflexive()
        // `arbId` is itself the witness for `containsId(ids1, arbId)`:
        assert tr.containsId(ids1, arbId)
    }
    assert arbId in ids2 ==> tr.containsId(ids1, arbId)
    // perform a forall introduction since `arbId` is unconstraint:
    assume forall id p.Id :: { tr.containsId(ids1, id) } id in ids2 ==> tr.containsId(ids1, id)
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) GetSkLabel(pk tm.Term) label.SecrecyLabel {
    return (pk.IsPk()) ?
        ctx.GetLabel(tm.getSk(pk)) :
        label.Public()
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) IsSecretKey(t tr.TraceEntry, owner p.Id, sk tm.Term, keyType KeyType, usage string) bool {
    return (keyType == KeyTypePke() ==> ctx.IsPrivateDecKey(t, owner, sk, usage)) &&
        (keyType == KeyTypeDh() ==> ctx.IsPrivateDhKey(t, owner, sk, usage)) &&
        (keyType == KeyTypeSigning() ==> ctx.IsPrivateSigningKey(t, owner, sk, usage))
}

ghost
decreases
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsSecretKey(t1, owner, sk, keyType, usage)
ensures  ctx.IsSecretKey(t2, owner, sk, keyType, usage)
func (ctx LabelingContext) IsSecretKeyMonotonic(t1, t2 tr.TraceEntry, owner p.Id, sk tm.Term, keyType KeyType, usage string) bool {
    if keyType == KeyTypePke() {
        ctx.IsPrivateDecKeyMonotonic(t1, t2, owner, sk, usage)
    } else if keyType == KeyTypeDh() {
        ctx.IsPrivateDhKeyMonotonic(t1, t2, owner, sk, usage)
    } else if keyType == KeyTypeSigning() {
        ctx.IsPrivateSigningKeyMonotonic(t1, t2, owner, sk, usage)
    }
}

ghost
decreases
requires ctx.Props()
requires ctx.IsSecretKey(t, owner, sk, keyType, usage)
ensures  ctx.IsLabeled(t, sk, label.Readers(set[p.Id]{ owner }))
func (ctx LabelingContext) IsSecretKeyLemma(t tr.TraceEntry, owner p.Id, sk tm.Term, keyType KeyType, usage string) {
    // the following assert stmt is needed for triggering reasons:
    assert getKeyTypeType(keyType) == 0 || getKeyTypeType(keyType) == 1 || getKeyTypeType(keyType) == 2
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) IsPublicKey(t tr.TraceEntry, skOwner p.Id, pk, sk tm.Term, keyType KeyType, usage string) bool {
    return (keyType == KeyTypePke() ==> ctx.IsPublicEncKey(t, skOwner, pk, sk, usage)) &&
        (keyType == KeyTypeDh() ==> ctx.IsPublicDhKey(t, skOwner, pk, sk, usage)) &&
        (keyType == KeyTypeSigning() ==> ctx.IsPublicSigningKey(t, skOwner, pk, sk, usage))
}

ghost
decreases
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsPublicKey(t1, skOwner, pk, sk, keyType, usage)
ensures  ctx.IsPublicKey(t2, skOwner, pk, sk, keyType, usage)
func (ctx LabelingContext) IsPublicKeyMonotonic(t1, t2 tr.TraceEntry, skOwner p.Id, pk, sk tm.Term, keyType KeyType, usage string) {
    if keyType == KeyTypePke() {
        ctx.IsPublicEncKeyMonotonic(t1, t2, skOwner, pk, sk, usage)
    } else if keyType == KeyTypeDh() {
        ctx.IsPublicDhKeyMonotonic(t1, t2, skOwner, pk, sk, usage)
    } else if keyType == KeyTypeSigning() {
        ctx.IsPublicSigningKeyMonotonic(t1, t2, skOwner, pk, sk, usage)
    }
}

ghost
decreases
requires ctx.Props()
requires ctx.IsPublicKey(t, skOwner, pk, sk, keyType, usageString)
ensures  ctx.IsLabeled(t, sk, label.Readers(set[p.Id]{ skOwner }))
func (ctx LabelingContext) IsPublicKeyLemma(t tr.TraceEntry, skOwner p.Id, pk, sk tm.Term, keyType KeyType, usageString string) {
    // the following assert stmt is needed for triggering reasons:
    assert getKeyTypeType(keyType) == 0 || getKeyTypeType(keyType) == 1 || getKeyTypeType(keyType) == 2
    var usage u.Usage
    if keyType == KeyTypePke() {
        usage = u.PkeKey(usageString)
    } else if keyType == KeyTypeDh() {
        usage = u.DhKey(usageString)
    } else if keyType == KeyTypeSigning() {
        usage = u.SigningKey(usageString)
    }
    assert ctx.IsSecret(t, sk, label.Readers(set[p.Id]{ skOwner }), usage)
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) IsPublicKeyExistential(t tr.TraceEntry, skOwner p.Id, pk tm.Term, keyType KeyType, usage string) bool {
    return (keyType == KeyTypePke() ==> exists sk tm.Term :: { ctx.IsPublicEncKey(t, skOwner, pk, sk, usage) } ctx.IsPublicEncKey(t, skOwner, pk, sk, usage)) &&
        (keyType == KeyTypeDh() ==> ctx.IsPublicDhKeyExistential(t, skOwner, pk, usage)) &&
        (keyType == KeyTypeSigning() ==> exists sk tm.Term :: { ctx.IsPublicSigningKey(t, skOwner, pk, sk, usage) } ctx.IsPublicSigningKey(t, skOwner, pk, sk, usage))
}

ghost
decreases
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsPublicKeyExistential(t1, skOwner, pk, keyType, usage)
ensures  ctx.IsPublicKeyExistential(t2, skOwner, pk, keyType, usage)
func (ctx LabelingContext) IsPublicKeyExistentialMonotonic(t1, t2 tr.TraceEntry, skOwner p.Id, pk tm.Term, keyType KeyType, usage string) {
    skWitness := arb.GetArbTerm()
	if keyType == KeyTypePke() {
		assert exists sk tm.Term :: { ctx.IsPublicEncKey(t1, skOwner, pk, sk, usage) } ctx.IsPublicEncKey(t1, skOwner, pk, sk, usage)
		// get witness
		assume ctx.IsPublicEncKey(t1, skOwner, pk, skWitness, usage)
	} else if keyType == KeyTypeDh() {
		assert exists sk tm.Term :: { ctx.IsPublicDhKey(t1, skOwner, pk, sk, usage) } ctx.IsPublicDhKey(t1, skOwner, pk, sk, usage)
		// get witness
		assume ctx.IsPublicDhKey(t1, skOwner, pk, skWitness, usage)
	} else if keyType == KeyTypeSigning() {
        assert exists sk tm.Term :: { ctx.IsPublicSigningKey(t1, skOwner, pk, sk, usage) } ctx.IsPublicSigningKey(t1, skOwner, pk, sk, usage)
		// get witness
		assume ctx.IsPublicSigningKey(t1, skOwner, pk, skWitness, usage)
    }
	ctx.IsPublicKeyMonotonic(t1, t2, skOwner, pk, skWitness, keyType, usage)
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) IsPrivateDecKey(t tr.TraceEntry, owner p.Id, sk tm.Term, usage string) bool {
    return sk == tm.random(tm.gamma(sk), label.Readers(set[p.Id]{ owner }), u.PkeKey(usage)) &&
        ctx.IsSecret(t, sk, label.Readers(set[p.Id]{ owner }), u.PkeKey(usage))
}

ghost
decreases
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsPrivateDecKey(t1, owner, sk, usage)
ensures  ctx.IsPrivateDecKey(t2, owner, sk, usage)
func (ctx LabelingContext) IsPrivateDecKeyMonotonic(t1, t2 tr.TraceEntry, owner p.Id, sk tm.Term, usage string) {
    ctx.IsSecretMonotonic(t1, t2, sk, label.Readers(set[p.Id]{ owner }), u.PkeKey(usage))
}

ghost
decreases
requires ctx.Props()
// sk is the witness
pure func (ctx LabelingContext) IsPublicEncKey(t tr.TraceEntry, skOwner p.Id, pk, sk tm.Term, usage string) bool {
    return ctx.IsPublishable(t, pk) &&
        ctx.IsPrivateDecKey(t, skOwner, sk, usage) &&
        pk == tm.createPk(sk)
}

ghost
decreases
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsPublicEncKey(t1, skOwner, pk ,sk, usage)
ensures  ctx.IsPublicEncKey(t2, skOwner, pk ,sk, usage)
func (ctx LabelingContext) IsPublicEncKeyMonotonic(t1, t2 tr.TraceEntry, skOwner p.Id, pk, sk tm.Term, usage string) {
    ctx.IsPublishableMonotonic(t1, t2, pk)
    ctx.IsPrivateDecKeyMonotonic(t1, t2, skOwner, sk, usage)
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) IsPublicEncKeyExistential(t tr.TraceEntry, pk tm.Term, l label.SecrecyLabel, usage string) bool {
    return ctx.IsPublishable(t, pk) &&
        pk.IsPk() &&
        ctx.IsSecret(t, tm.getSk(pk), l, u.PkeKey(usage))
}

ghost
decreases
requires ctx.Props()
// sk is the witness
pure func (ctx LabelingContext) IsPrivateDhKey(t tr.TraceEntry, owner p.Id, sk tm.Term, usage string) bool {
    return sk.IsRandom() &&
        ctx.IsSecret(t, sk, label.Readers(set[p.Id]{ owner }), u.DhKey(usage))
}

ghost
decreases
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsPrivateDhKey(t1, owner, sk, usage)
ensures  ctx.IsPrivateDhKey(t2, owner, sk, usage)
func (ctx LabelingContext) IsPrivateDhKeyMonotonic(t1, t2 tr.TraceEntry, owner p.Id, sk tm.Term, usage string) {
    ctx.IsSecretMonotonic(t1, t2, sk, label.Readers(set[p.Id]{ owner }), u.DhKey(usage))
}

ghost
decreases
requires ctx.Props()
// sk is the witness
pure func (ctx LabelingContext) IsPrivateSigningKey(t tr.TraceEntry, owner p.Id, sk tm.Term, usage string) bool {
    return sk.IsRandom() &&
        ctx.IsSecret(t, sk, label.Readers(set[p.Id]{ owner }), u.SigningKey(usage))
}

ghost
decreases
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsPrivateSigningKey(t1, owner, sk, usage)
ensures  ctx.IsPrivateSigningKey(t2, owner, sk, usage)
func (ctx LabelingContext) IsPrivateSigningKeyMonotonic(t1, t2 tr.TraceEntry, owner p.Id, sk tm.Term, usage string) {
    ctx.IsSecretMonotonic(t1, t2, sk, label.Readers(set[p.Id]{ owner }), u.SigningKey(usage))
}

ghost
decreases
requires ctx.Props()
// sk is the witness
pure func (ctx LabelingContext) IsPublicDhKey(t tr.TraceEntry, skOwner p.Id, pk, sk tm.Term, usage string) bool {
    return ctx.IsPublishable(t, pk) &&
        pk == tm.exp(tm.generator(), sk) &&
        ctx.IsPrivateDhKey(t, skOwner, sk, usage)
}

ghost
decreases
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsPublicDhKey(t1, skOwner, pk, sk, usage)
ensures  ctx.IsPublicDhKey(t2, skOwner, pk, sk, usage)
func (ctx LabelingContext) IsPublicDhKeyMonotonic(t1, t2 tr.TraceEntry, skOwner p.Id, pk, sk tm.Term, usage string) {
    ctx.IsPublishableMonotonic(t1, t2, pk)
    ctx.IsPrivateDhKeyMonotonic(t1, t2, skOwner, sk, usage)
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) IsPublicDhKeyExistential(t tr.TraceEntry, skOwner p.Id, pk tm.Term, usage string) bool {
    return exists sk tm.Term :: { ctx.IsPublicDhKey(t, skOwner, pk, sk, usage) } ctx.IsPublicDhKey(t, skOwner, pk, sk, usage)
}

ghost
decreases
requires ctx.Props()
// sk is the witness
pure func (ctx LabelingContext) IsPublicSigningKey(t tr.TraceEntry, skOwner p.Id, pk, sk tm.Term, usage string) bool {
    return ctx.IsPublishable(t, pk) &&
        pk == tm.createPk(sk) &&
        ctx.IsPrivateSigningKey(t, skOwner, sk, usage)
}

ghost
decreases
requires ctx.Props()
requires t1.isSuffix(t2)
requires ctx.IsPublicSigningKey(t1, skOwner, pk, sk, usage)
ensures  ctx.IsPublicSigningKey(t2, skOwner, pk, sk, usage)
func (ctx LabelingContext) IsPublicSigningKeyMonotonic(t1, t2 tr.TraceEntry, skOwner p.Id, pk, sk tm.Term, usage string) {
    ctx.IsPublishableMonotonic(t1, t2, pk)
    ctx.IsPrivateSigningKeyMonotonic(t1, t2, skOwner, sk, usage)
}

ghost
decreases
requires ctx.Props()
requires ctx.IsMsg(t, term, l1)
requires ctx.CanFlow(t, l1, l2)
ensures  ctx.IsMsg(t, term, l2)
func (ctx LabelingContext) Restrict(t tr.TraceEntry, term tm.Term, l1, l2 label.SecrecyLabel) {
    ctx.CanFlowTransitive(t, ctx.GetLabel(term), l1, l2)
}

pred (ctx LabelingContext) NonceIsUnique(nonce tm.Term) {
    acc(ctx.getNonceIsUniquePointer(nonce))
}

pred (ctx LabelingContext) NonceForEventIsUnique(nonce tm.Term, eventType ev.EventType) {
    acc(ctx.getNonceForEventIsUniquePointer(nonce, eventType))
}

// each nonce term is (injectively) mapped to a heap location for which write access
// is obtained as part of the nonce generation algorithm.
// Pairwise disjointness of nonces / their uniqueness directly follows from this property
// as otherwise the `NonceIsUnique` resource would be stored twice on the trace which immediately
// results in a contradiction when unfolding the predicate instances
type Void int // note that `struct{}` results in Gobra not generating the expected heap permissions
ghost
pure func (ctx LabelingContext) getNonceIsUniquePointer(nonce tm.Term) *Void

ghost
pure func (ctx LabelingContext) getNonceForEventIsUniquePointer(nonce tm.Term, eventType ev.EventType) *Void

ghost
decreases
requires ctx.Props()
requires acc(ctx.NonceForEventIsUnique(nonce, eventType), 2/1)
ensures  false
func (ctx LabelingContext) NonceForEventContradiction(nonce tm.Term, eventType ev.EventType) {
    unfold acc(ctx.NonceForEventIsUnique(nonce, eventType), 2/1)
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) CanEncrypt(t tr.TraceEntry, msg, pk tm.Term) bool {
    return ctx.IsPublishable(t, pk) &&
        ctx.IsPkeKey(tm.getSk(pk)) &&
        ctx.IsMsg(t, msg, ctx.GetSkLabel(pk)) &&
        (forall usageString string :: { ctx.usage.PkePred(t, usageString, msg, pk) } ctx.IsPublicEncKeyExistential(t, pk, ctx.GetSkLabel(pk), usageString) ==>
            ctx.usage.PkePred(t, usageString, msg, pk))
}

ghost
decreases
requires ctx.Props()
requires ctx.CanEncrypt(t, msg, pk) || (ctx.IsPublishable(t, msg) && ctx.IsPublishable(t, pk))
ensures  ctx.IsPublishable(t, tm.encrypt(msg, pk))
func (ctx LabelingContext) CiphertextIsPublishable(t tr.TraceEntry, msg, pk tm.Term) {
    msgLabel := ctx.GetLabel(msg)
    if ctx.IsPublishable(t, msg) {
        ctx.FlowsToPublicCanFlow(t, msgLabel, ctx.GetSkLabel(pk))
    }
    // the following assert stmt is necessary:
	assert ctx.IsValidEncrypt(t, pk, msg, msgLabel)
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) CanDecrypt(t tr.TraceEntry, ciphertext, sk tm.Term, skOwner p.Id) bool {
    return ctx.IsPublishable(t, ciphertext) &&
        (ctx.IsPublishable(t, sk) || exists usageString string :: { ctx.IsPrivateDecKey(t, skOwner, sk, usageString) } ctx.IsPrivateDecKey(t, skOwner, sk, usageString))
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) WasDecrypted(t tr.TraceEntry, msg, sk tm.Term, skOwner p.Id) bool {
    return ctx.IsLabeled(t, sk, label.Readers(set[p.Id]{ skOwner })) ==>
        (ctx.IsMsg(t, msg, label.Readers(set[p.Id]{ skOwner })) &&
        (forall usageString string :: { ctx.IsPrivateDecKey(t, skOwner, sk, usageString) } ctx.IsPrivateDecKey(t, skOwner, sk, usageString) ==>
            ctx.IsPublishable(t, msg) || ctx.usage.PkePred(t, usageString, msg, tm.createPk(sk))))
}

ghost
decreases
requires ctx.Props()
requires ctx.IsPublishable(t, ciphertext) && ctx.IsPublishable(t, sk)
ensures  ctx.CanDecrypt(t, ciphertext, sk, skOwner)
func (ctx LabelingContext) CanDecryptWithPublicSk(t tr.TraceEntry, ciphertext, sk tm.Term, skOwner p.Id) {
    // no body needed
}

ghost
decreases
requires ctx.Props()
requires ctx.CanDecrypt(t, tm.encrypt(msg, tm.createPk(sk)), sk, skOwner)
ensures  ctx.WasDecrypted(t, msg, sk, skOwner)
func (ctx LabelingContext) DecryptSatisfiesInvariant(t tr.TraceEntry, msg, sk tm.Term, skOwner p.Id) {
    pk := tm.createPk(sk)
	plaintextLabel := ctx.GetLabel(msg)
	skLabel := ctx.GetLabel(sk)
	// the following assertion is necessary to derive that `ctx.IsMsg(t, msg, skLabel)`
	assert ctx.IsValidEncrypt(t, pk, msg, plaintextLabel)
	if (ctx.CanFlow(t, plaintextLabel, label.Public())) {
		ctx.CanFlowTransitive(t, plaintextLabel, label.Public(), skLabel)
	}
}

ghost
decreases
requires ctx.Props()
requires ctx.IsPublishable(t, tm.encrypt(msg, tm.createPk(sk))) && ctx.IsPublishable(t, sk)
ensures  ctx.IsPublishable(t, msg)
func (ctx LabelingContext) PlaintextIsPublishableForPublicSk(t tr.TraceEntry, msg, sk tm.Term, skOwner p.Id) {
    pk := tm.createPk(sk)
	plaintextLabel := ctx.GetLabel(msg)
	skLabel := ctx.GetLabel(sk)
	// the following assertion is necessary to derive that `ctx.IsMsg(t, msg, skLabel)`
	assert ctx.IsValidEncrypt(t, pk, msg, plaintextLabel)
    ctx.CanFlowTransitive(t, plaintextLabel, skLabel, label.Public())
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) CanAeadEncrypt(t tr.TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel) bool {
    return ctx.IsLabeledRelaxed(t, key, keyL) &&
        (ctx.IsPublishable(t, key) || exists usageString string :: ctx.IsAeadKey(t, key, keyL, usageString)) &&
        ctx.IsPublishable(t, nonce) &&
        ctx.IsMsg(t, msg, keyL) &&
        ctx.IsPublishable(t, ad) &&
        (forall usageString string :: ctx.IsAeadKey(t, key, keyL, usageString) ==> ctx.usage.AeadPred(t, usageString, key, nonce, msg, ad))
}

ghost
decreases
requires ctx.Props()
requires ctx.CanAeadEncrypt(t, key, nonce, msg, ad, keyL) || (ctx.IsPublishable(t, key) && ctx.IsPublishable(t, nonce) && ctx.IsPublishable(t, msg) && ctx.IsPublishable(t, ad))
ensures  ctx.IsPublishable(t, tm.aead(key, nonce, msg, ad))
func (ctx LabelingContext) AeadCiphertextIsPublishable(t tr.TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel) {
    msgL := ctx.GetLabel(msg)
    if ctx.IsPublishable(t, key) {
        if !ctx.IsPublishable(t, msg) {
            ctx.CanFlowTransitive(t, keyL, ctx.GetLabel(key), label.Public())
            ctx.CanFlowTransitive(t, msgL, keyL, label.Public())
        }
    } else {
        usageCtx := ctx.GetUsage(key)
        // the following assert stmt would not be necessary:
        assert ctx.usage.AeadPred(t, u.GetUsageString(get(usageCtx)), key, nonce, msg, ad)
        ctx.CanFlowTransitive(t, msgL, keyL, ctx.GetLabel(key))
    }
    // the following assert stmt is necessary:
	assert ctx.IsValidAead(t, key, nonce, msg, msgL, ad)
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) CanAeadDecrypt(t tr.TraceEntry, key, nonce, ciphertext, ad tm.Term, keyL label.SecrecyLabel) bool {
    return true
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) WasAeadDecrypted(t tr.TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel) bool {
    return ((ctx.IsPublishable(t, key) || exists usageString string :: ctx.IsAeadKey(t, key, keyL, usageString)) &&
        ctx.IsPublishable(t, nonce) &&
        ctx.IsPublishable(t, tm.aead(key, nonce, msg, ad)) &&
        ctx.IsPublishable(t, ad)) ==>
            (ctx.IsMsg(t, msg, ctx.GetLabel(key)) &&
            (forall usageString string :: { ctx.IsAeadKey(t, key, keyL, usageString) } ctx.IsAeadKey(t, key, keyL, usageString) ==>
                // either the attacker has applied AEAD encryption or AeadPred holds
                // in the first case, this requires that all components are known by the attacker (i.e. key, nonce, msg, and ad)
                (ctx.IsPublishable(t, key) && ctx.IsPublishable(t, msg)) || ctx.usage.AeadPred(t, usageString, key, nonce, msg, ad)))
}

ghost
decreases
requires ctx.Props()
requires ctx.IsPublishable(t, key) && ctx.IsPublishable(t, nonce) && ctx.IsPublishable(t, ciphertext) && ctx.IsPublishable(t, ad)
ensures  ctx.CanAeadDecrypt(t, key, nonce, ciphertext, ad, keyL)
func (ctx LabelingContext) CanAeadDecryptWithPublishableKey(t tr.TraceEntry, key, nonce, ciphertext, ad tm.Term, keyL label.SecrecyLabel) {
    // no body needed
}

ghost
decreases
requires ctx.Props()
requires ctx.CanAeadDecrypt(t, key, nonce, tm.aead(key, nonce, msg, ad), ad, keyL)
ensures  ctx.WasAeadDecrypted(t, key, nonce, msg, ad, keyL)
func (ctx LabelingContext) AeadDecryptSatisfiesInvariant(t tr.TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel) {
    if ((ctx.IsPublishable(t, key) || exists usageString string :: ctx.IsAeadKey(t, key, keyL, usageString)) &&
        ctx.IsPublishable(t, nonce) &&
        ctx.IsPublishable(t, tm.aead(key, nonce, msg, ad)) &&
        ctx.IsPublishable(t, ad)) {
        msgL := ctx.GetLabel(msg)
	    // the following assertion is necessary to derive that `ctx.IsMsg(t, msg, keyL)`
	    assert ctx.IsValidAead(t, key, nonce, msg, msgL, ad)
	    if (ctx.CanFlow(t, msgL, label.Public())) {
	        ctx.CanFlowTransitive(t, msgL, label.Public(), ctx.GetLabel(key))
	    }
    }
}

ghost
decreases
requires ctx.Props()
requires ctx.IsPublishable(t, tm.aead(key, nonce, msg, ad)) && ctx.IsPublishable(t, key) && ctx.IsPublishable(t, nonce) && ctx.IsPublishable(t, ad)
ensures  ctx.IsPublishable(t, msg)
func (ctx LabelingContext) PlaintextIsPublishableForPublishableKey(t tr.TraceEntry, key, nonce, msg, ad tm.Term, keyL label.SecrecyLabel) {
    if ((ctx.IsPublishable(t, key) || exists usageString string :: ctx.IsAeadKey(t, key, keyL, usageString)) &&
        ctx.IsPublishable(t, nonce) &&
        ctx.IsPublishable(t, tm.aead(key, nonce, msg, ad)) &&
        ctx.IsPublishable(t, ad)) {
        msgL := ctx.GetLabel(msg)
	    // the following assertion is necessary to derive that `ctx.IsMsg(t, msg, keyL)`
	    assert ctx.IsValidAead(t, key, nonce, msg, msgL, ad)
	    if !ctx.CanFlow(t, msgL, label.Public()) {
            ctx.CanFlowTransitive(t, msgL, ctx.GetLabel(key), label.Public())
        }
    }
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) CanSign(t tr.TraceEntry, msg, sk tm.Term, skOwner p.Id) bool {
    return ctx.IsPublishable(t, msg) &&
        ctx.IsLabeledRelaxed(t, sk, label.Readers(set[p.Id]{ skOwner })) &&
        (ctx.IsPublishable(t, sk) || exists usageString string :: ctx.IsSignKey(t, sk, skOwner, usageString)) &&
        (forall usageString string :: { ctx.usage.SignPred(t, usageString, msg, sk) } ctx.IsSignKey(t, sk, skOwner, usageString) ==>
            ctx.usage.SignPred(t, usageString, msg, sk))
}

ghost
decreases
requires ctx.Props()
requires ctx.CanSign(t, msg, sk, skOwner) || (ctx.IsPublishable(t, msg) && ctx.IsPublishable(t, sk))
ensures  ctx.IsPublishable(t, tm.sign(msg, sk))
func (ctx LabelingContext) SignedMessageIsPublishable(t tr.TraceEntry, msg, sk tm.Term, skOwner p.Id) {
    msgL := ctx.GetLabel(msg)
    if !ctx.IsPublishable(t, sk) {
        usageCtx := ctx.GetUsage(sk)
        // the following assert stmt would not be necessary:
        assert ctx.usage.SignPred(t, u.GetUsageString(get(usageCtx)), msg, sk)
    }
    // the following assert stmt is necessary:
	assert ctx.IsValidSignature(t, msg, sk)
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) CanOpen(t tr.TraceEntry, signedData, pk tm.Term, skOwner p.Id) bool {
    return true
}

ghost
decreases
requires ctx.Props()
pure func (ctx LabelingContext) WasOpened(t tr.TraceEntry, msg, sk tm.Term, skOwner p.Id) bool {
    return ctx.IsValid(t, tm.sign(msg, sk)) ==>
        (forall usageString string :: { ctx.IsSignKey(t, sk, skOwner, usageString) } ctx.IsSignKey(t, sk, skOwner, usageString) ==>
            // either the attacker has signed ...
            (ctx.IsPublishable(t, sk) && ctx.IsPublishable(t, msg)) ||
                // ... or SignPred holds
                ctx.usage.SignPred(t, usageString, msg, sk))
}

ghost
decreases
requires ctx.Props()
requires ctx.IsPublishable(t, signedData) && ctx.IsPublishable(t, pk)
ensures  ctx.CanOpen(t, signedData, pk, skOwner)
func (ctx LabelingContext) CanOpenWithPublishableKey(t tr.TraceEntry, signedData, pk tm.Term, skOwner p.Id) {
    // no body needed
}

ghost
decreases
requires ctx.Props()
requires ctx.CanOpen(t, tm.sign(msg, sk), tm.createPk(sk), skOwner)
ensures  ctx.WasOpened(t, msg, sk, skOwner)
func (ctx LabelingContext) OpenSatisfiesInvariant(t tr.TraceEntry, msg, sk tm.Term, skOwner p.Id) {
    // the following assertion is necessary:
    if ctx.IsValid(t, tm.sign(msg, sk)) {
        assert ctx.IsValidSignature(t, msg, sk)
    }
}

ghost
decreases
requires ctx.Props()
requires ctx.IsPublishable(t, tm.sign(msg, sk))
ensures  ctx.IsPublishable(t, msg)
func (ctx LabelingContext) UnsignedDataIsPublishableIfSignatureIsPublishable(t tr.TraceEntry, msg, sk tm.Term) {
    // the following assertion is necessary:
	assert ctx.IsValidSignature(t, msg, sk)
}

ghost
decreases
requires ctx.Props()
requires ctx.IsLabeled(t, term, l)
requires l.IsReaders()
requires !tr.containsCorruptId(t.getCorruptIds(), label.GetReaders(l))
ensures  !ctx.IsPublishable(t, term)
func (ctx LabelingContext) PublishableRequiresCorruption(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    // no body needed
}

ghost
decreases
requires ctx.Props()
requires ctx.IsLabeledRelaxed(t, term, l)
requires l.IsReaders()
requires !tr.containsCorruptId(t.getCorruptIds(), label.GetReaders(l))
ensures  !ctx.IsPublishable(t, term)
/**
  * weakened version of `PublishableRequiresCorruption`: instead of requiring `term` being
  * labeled with a `Readers` label, we can permit any label to which `Readers` (i.e. `l`) flows to
  */
func (ctx LabelingContext) PublishableRequiresCorruptionWeakened(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    // proof by contradiction:
    // we assume that `l` flows to public and show then that term's actual label would flow
    // to public as well, which contradicts the precondition that `l` does not
    // contain any corrupted IDs:
    termL := ctx.GetLabel(term)
    if ctx.CanFlow(t, termL, label.Public()) {
        ctx.CanFlowTransitive(t, l, termL, label.Public())
        // this is a contradiction as l would flow to public!
    }
}

ghost
decreases
requires ctx.Props()
requires ctx.IsLabeledRelaxed(t, term, l)
requires l.IsReaders()
requires ctx.IsPublishable(t, term)
ensures  tr.containsCorruptId(t.getCorruptIds(), label.GetReaders(l))
ensures  corruptedId in t.getCorruptIds()
ensures  id in label.GetReaders(l) && id.Covers(corruptedId)
func (ctx LabelingContext) PublishableImpliesCorruption(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) (corruptedId, id p.Id) {
    termL := ctx.GetLabel(term)
    readers := label.GetReaders(l)
    corruptIds := t.getCorruptIds()
    ctx.CanFlowTransitive(t, l, termL, label.Public())
    // apply `containsCorruptId(corruptIds, readers)`:
    assert exists corruptedId p.Id :: { tr.containsId(readers, corruptedId) } corruptedId in corruptIds && tr.containsId(readers, corruptedId)
    // get witness
    corruptedId = arb.GetArbId()
    assume corruptedId in corruptIds && tr.containsId(readers, corruptedId)
    // apply `containsId(readers, corruptedId)`:
    assert exists id p.Id :: { id.Covers(corruptedId) } id in readers && id.Covers(corruptedId)
    // get witness
    id = arb.GetArbId()
    assume id in readers && id.Covers(corruptedId)
}

ghost
decreases
requires ctx.Props()
requires ctx.IsMsg(t, term, l)
requires l.IsReaders()
requires !ctx.IsPublishable(t, term)
ensures  !tr.containsCorruptId(t.getCorruptIds(), label.GetReaders(l))
func (ctx LabelingContext) NotPublishableImpliesNoCorruption(t tr.TraceEntry, term tm.Term, l label.SecrecyLabel) {
    if ctx.CanFlow(t, l, label.Public()) {
        // derive a contradiction:
        ctx.CanFlowTransitive(t, ctx.GetLabel(term), l, label.Public())
    }
}

ghost
decreases
requires ctx.Props()
requires l1.IsReaders() && l2.IsReaders()
requires ctx.IsLabeledRelaxed(t, term, label.Join(l1, l2))
ensures  optCorruptedId == none[p.Id] ?
    !ctx.IsPublishable(t, term) :
    ((tr.containsId(label.GetReaders(l1), get(optCorruptedId)) || tr.containsId(label.GetReaders(l2), get(optCorruptedId))) &&
        get(optCorruptedId) in t.getCorruptIds() &&
        tr.containsCorruptId(t.getCorruptIds(), label.GetReaders(l1) union label.GetReaders(l2)))
func (ctx LabelingContext) RelaxedLabelingImpliesNotPublishableOrCorruption(t tr.TraceEntry, term tm.Term, l1, l2 label.SecrecyLabel) (optCorruptedId option[p.Id]) {
    termL := ctx.GetLabel(term)
    if ctx.IsPublishable(t, term) {
        joinL := label.Join(l1, l2)
        ctx.CanFlowTransitive(t, joinL, termL, label.Public())
        // the following assert stmt is necessary:
        assert ctx.CanFlow(t, l1, label.Public()) || ctx.CanFlow(t, l2, label.Public())
        if ctx.CanFlow(t, l1, label.Public()) {
            assert exists corruptedId p.Id :: { tr.containsId(label.GetReaders(l1), corruptedId) } corruptedId in t.getCorruptIds() && tr.containsId(label.GetReaders(l1), corruptedId)
            corruptedId := arb.GetArbId()
            assume corruptedId in t.getCorruptIds() && tr.containsId(label.GetReaders(l1), corruptedId)
            optCorruptedId = some(corruptedId)
        } else {
            assert exists corruptedId p.Id :: { tr.containsId(label.GetReaders(l2), corruptedId) } corruptedId in t.getCorruptIds() && tr.containsId(label.GetReaders(l2), corruptedId)
            corruptedId := arb.GetArbId()
            assume corruptedId in t.getCorruptIds() && tr.containsId(label.GetReaders(l2), corruptedId)
            optCorruptedId = some(corruptedId)
        }
        ctx.containsCorruptIdNotUnion(t.getCorruptIds(), label.GetReaders(l1), label.GetReaders(l2))
    } else {
        optCorruptedId = none[p.Id]
    }
}
